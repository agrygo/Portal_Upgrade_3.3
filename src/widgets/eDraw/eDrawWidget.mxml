<?xml version="1.0" encoding="utf-8"?>
<!--
///////////////////////////////////////////////////////////////////////////
// Copyright (c) 2010-2011 Esri. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
///////////////////////////////////////////////////////////////////////////
-->
<viewer:BaseWidget xmlns:esri="http://www.esri.com/2008/ags"
                   xmlns:fx="http://ns.adobe.com/mxml/2009"
                   xmlns:s="library://ns.adobe.com/flex/spark"
                   xmlns:mx="library://ns.adobe.com/flex/mx"
                   xmlns:viewer="com.esri.viewer.*"
                   xmlns:components="com.esri.viewer.components.*"
                   xmlns:eDraw="widgets.eDraw.*"
                   x="600" y="300"
                   initialize="basewidget_initializeHandler()"
                   widgetConfigLoaded="basewidget_widgetConfigLoaded()">
    <fx:Script>
        <![CDATA[
            import com.esri.ags.Graphic;
            import com.esri.ags.SpatialReference;
            import com.esri.ags.Units;
            import com.esri.ags.events.DrawEvent;
            import com.esri.ags.events.EditEvent;
            import com.esri.ags.events.GeometryServiceEvent;
            import com.esri.ags.events.GraphicEvent;
            import com.esri.ags.geometry.Extent;
            import com.esri.ags.geometry.Geometry;
            import com.esri.ags.geometry.MapPoint;
            import com.esri.ags.geometry.Polygon;
            import com.esri.ags.geometry.Polyline;
            import com.esri.ags.layers.GraphicsLayer;
            import com.esri.ags.symbols.SimpleFillSymbol;
            import com.esri.ags.symbols.SimpleLineSymbol;
            import com.esri.ags.symbols.SimpleMarkerSymbol;
            import com.esri.ags.symbols.TextSymbol;
            import com.esri.ags.tasks.GeometryService;
            import com.esri.ags.tasks.GeometryServiceSingleton;
            import com.esri.ags.tasks.supportClasses.ProjectParameters;
            import com.esri.ags.tools.DrawTool;
            import com.esri.ags.utils.GeometryUtil;
            import com.esri.ags.utils.GraphicUtil;
            import com.esri.ags.utils.JSONUtil;
            import com.esri.ags.utils.WebMercatorUtil;
            import com.esri.viewer.AppEvent;
            import com.esri.viewer.ViewerContainer;
            
            import mx.collections.ArrayCollection;
            import mx.controls.Alert;
            import mx.core.FTETextField;
            import mx.events.CloseEvent;
            import mx.managers.CursorManager;
            import mx.managers.CursorManagerPriority;
            import mx.rpc.AsyncResponder;
            import mx.rpc.Fault;
            import mx.rpc.events.FaultEvent;
            
            import spark.collections.Sort;

            private const ICON_URL:String = "assets/images/";
            private const TEXT_MODE:String = "text";
            private const EPSG_GEOGRAPHIC:Number = 4326;

            [Bindable]
            private var fontList:ArrayList;
            [Bindable]
            private var isMeasuringEnabled:Boolean;
            //labels
            [Bindable]
            private var textLabel:String;
            [Bindable]
            private var textColorLabel:String;
            [Bindable]
            private var textFontLabel:String;
            [Bindable]
            private var textSizeLabel:String;
            [Bindable]
            private var textBoldLabel:String;
            [Bindable]
            private var textBoldTooltip:String;
            [Bindable]
            private var textItalicLabel:String;
            [Bindable]
            private var textItalicTooltip:String;
            [Bindable]
            private var textUnderlineLabel:String;
            [Bindable]
            private var textUnderlineTooltip:String;
//My Add
            [Bindable]
            private var markerRotationLabel:String;
            [Bindable]
            private var textRotateLabel:String;
            [Bindable]
            private var isHaloEnabled:Boolean;
            [Bindable]
            private var AddHaloLbl:String;
            [Bindable]
            private var fontWarnMsg:String;
            [Bindable]
            private var fontWarnTitle:String;
//End My Add
            
            //points
            [Bindable]
            private var addTextLabel:String;
            [Bindable]
            private var drawPointLabel:String;
            [Bindable]
            private var markerAlphaLabel:String;
            [Bindable]
            private var markerColorLabel:String;
            [Bindable]
            private var markerSizeLabel:String;
            [Bindable]
            private var markerStyleLabel:String;
            [Bindable]
            private var markerOutlineColorLabel:String;
            [Bindable]
            private var markerOutlineWidthLabel:String;

            // lines
            [Bindable]
            private var drawLineLabel:String;
            [Bindable]
            private var drawFreehandLineLabel:String;
            [Bindable]
            private var lineAlphaLabel:String;
            [Bindable]
            private var lineColorLabel:String;
            [Bindable]
            private var lineStyleLabel:String;
            [Bindable]
            private var lineWidthLabel:String;

            // polygons
            [Bindable]
            private var drawPolygonLabel:String;
            [Bindable]
            private var drawFreehandPolygonLabel:String;
            [Bindable]
            private var drawRectangleLabel:String;
            [Bindable]
            private var drawCircleLabel:String;
            [Bindable]
            private var drawEllipseLabel:String;
            [Bindable]
            private var fillAlphaLabel:String;
            [Bindable]
            private var fillColorLabel:String;
            [Bindable]
            private var fillStyleLabel:String;
            [Bindable]
            private var fillOutlineColorLabel:String;
            [Bindable]
            private var fillOutlineWidthLabel:String;
//My Add
            [Bindable]
            private var fillOutlineAlphaLabel:String;
            [Bindable]
            private var PointXY:Boolean;
            [Bindable]
            private var pointsUnitsLabel:String;
            [Bindable]
            private var configPoint:ArrayList;
            private var zoomPercent:Number = 1.2;
            private var autoZoom:Boolean;
            private var disableLiveMeasure:Boolean;
//End My Add

            [Bindable]
            private var clearLabel:String;
            private var clearFeatureLabel:String;

            private var areaLabel:String;
            [Bindable]
            private var areaUnitsLabel:String;
            [Bindable]
            private var distanceUnitsLabel:String;
            [Bindable]
            private var showMeasurements:Boolean;
            [Bindable]
            private var showmeasurementsLabel:String;

            [Bindable]
            private var configArea:ArrayList;
            [Bindable]
            private var configDistance:ArrayList;
            [Bindable]
            private var graphicsLayer:GraphicsLayer;
            [Bindable]
            private var drawingPoint:Boolean;
            [Bindable]
            private var addingText:Boolean;
            [Bindable]
            private var drawingLine:Boolean;
            [Bindable]
            private var drawingPolygon:Boolean;
            [Bindable]
            private var defaultDrawColor:uint;
            [Bindable]
            private var defaultTextFontSize:Number;

            [Bindable]
            private var hasDrawnGraphics:Boolean;

            private var drawMode:String;
            private var lengthLabel:String;
            private var perimeterLabel:String;
            private var measurePt:MapPoint;
            private var drawType:String;
            private var drawStatus:String;
            private var selectedDrawingIcon:FocusableImage;
            private var lastDrawnGraphic:Graphic;
            private var editGraphic:Graphic;
            private var isEditing:Boolean;
            private var lastActiveEditType:String = "none"; // edit tool is not active

            [Embed(source="/assets/images/move_cursor.png")]
            private var moveCursorIcon:Class;
            
//My Add
            //Build Constants
            protected const VERSION:String = "3.3.2";
            protected const BUILDDATE:String = "5/17/2013";
            
            //Resources
            [Embed(source="assets/images/i_about.png")]
            private var iconClass:Class;
            
            [Embed(source="assets/images/i_warning.png")]
            private var expClass:Class;
//End My Add

            private var moveCursorIconId:int;
            private var graphicToMeasurementGraphic:Dictionary = new Dictionary(true);
            
//My Add
            private var finishDrawing:Boolean;
            private var WIDGET_URL:String = "widgets/eDraw/assets/images/";
            [Bindable]
            private var drawAC:ArrayCollection;
            
            private var fr:FileReference;
            
            [Bindable]
            private var saveLabel:String;
            
            [Bindable]
            private var openLabel:String;
            
            private var useDefaultFont:Boolean = false;
            
            [Bindable]
            private var numPrecision:int;
            
            [Bindable]
            private var geonumPrecision:int;
            
            [Bindable]
            private var dmsnumPrecision:int;
            
            [Bindable]
            private var dddnumPrecision:int;
            
            private var defaultTool:String;
//End My Add

            private function basewidget_initializeHandler():void
            {
                if (isPartOfPanel) // if widget is part of "left", "right" or "bottom" panel
                {
                    this.percentWidth = this.percentHeight = 100;
                    wTemplate.percentWidth = wTemplate.percentHeight = 100;
                }
                else
                {
                    wTemplate.width = wTemplate.minWidth = 420;
                    wTemplate.height = wTemplate.minHeight = 300;
                }
            }

            private function basewidget_widgetConfigLoaded():void
            {
                graphicsLayer = new GraphicsLayer();
                map.addLayer(graphicsLayer);

                if (configXML)
                {
                    geometryService.url = GeometryServiceSingleton.instance.url;
                    geometryService.token = GeometryServiceSingleton.instance.token;
                    geometryService.proxyURL = GeometryServiceSingleton.instance.proxyURL;

                    graphicsLayer.name = configXML.layername || widgetTitle;
                    
//My Add					
                    if(configXML.autoloadgraphics[0]){
                        if(configXML.autoloadgraphics.@zoompercent){
                            zoomPercent = Number(configXML.autoloadgraphics.@zoompercent)
                        }else{
                            zoomPercent = 1.2
                        }
                        autoZoom = configXML.autoloadgraphics.@autozoom && configXML.autoloadgraphics.@autozoom == "true";
                        const urlLoader:URLLoader = new URLLoader();
                        urlLoader.dataFormat = URLLoaderDataFormat.BINARY;
                        urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, doNothing);
                        urlLoader.addEventListener(IOErrorEvent.IO_ERROR, doNothing);
                        urlLoader.addEventListener(Event.COMPLETE, onLoadComplete2);
                        const request:URLRequest = new URLRequest(configXML.autoloadgraphics);
                        request.method = URLRequestMethod.POST;
                        urlLoader.load(request);
                        
                        function doNothing(event:Event):void
                        {
                            const loader:URLLoader = event.target as URLLoader;
                            loader.close();
                        }
                    }
//End My Add

                    initializeFontList();

                    defaultDrawColor = configXML.defaultdrawcolor || 0x3FAFDC;
                    defaultTextFontSize = configXML.defaulttextfontsize || 20;
                    // drawing labels
                    textLabel = configXML.labels.textlabel || getDefaultString("textLabel");
                    textColorLabel = configXML.labels.textcolorlabel || getDefaultString("textColorLabel");
                    textFontLabel = configXML.labels.textfontlabel || getDefaultString("textFontLabel");
                    textSizeLabel = configXML.labels.sizelabel || getDefaultString("textSizeLabel");
                    textBoldLabel = configXML.labels.textboldlabel || getDefaultString("textBoldLabel");
                    textBoldTooltip = configXML.labels.textboldtooltip || getDefaultString("textBoldTooltip");
                    textItalicLabel = configXML.labels.textitaliclabel || getDefaultString("textItalicLabel");
                    textItalicTooltip = configXML.labels.textitalictooltip || getDefaultString("textItalicTooltip");
                    textUnderlineLabel = configXML.labels.textunderlinelabel || getDefaultString("textUnderlineLabel");
                    textUnderlineTooltip = configXML.labels.textunderlinetooltip || getDefaultString("textUnderlineTooltip");
//My Add
                    textRotateLabel = configXML.labels.textrotationlabel || "Rotation";
                    WIDGET_URL = config.substring(0,config.lastIndexOf("/")) + "/assets/images/";
                    AddHaloLbl = configXML.labels.addhalolabel || "Add Halo";
                    isHaloEnabled = configXML.addhalototext && configXML.addhalototext == "true";
                    fontWarnMsg = configXML.labels.fontwarningmsg || "If you are using a non standard font and sharing this saved graphics layer with another computer there is a possibility that that machine could not have the font installed and would cause and error when loaded. Do you want to switch the font to Arial?";
                    fontWarnTitle = configXML.labels.fontwarningtitle || "Warning";
                    disableLiveMeasure = configXML.disablelivemeasure && configXML.disablelivemeasure == "true";
//End My Add
                    
                    // points
                    drawPointLabel = configXML.labels.drawpointlabel || getDefaultString("drawPointLabel");
                    addTextLabel = configXML.labels.addtextlabel || getDefaultString("addTextLabel");
                    markerColorLabel = configXML.labels.markercolorlabel || getDefaultString("markerColorLabel");
                    markerAlphaLabel = configXML.labels.markeralphalabel || getDefaultString("markerAlphaLabel");
                    markerSizeLabel = configXML.labels.markersizelabel || getDefaultString("markerSizeLabel");
                    markerStyleLabel = configXML.labels.markerstylelabel || getDefaultString("markerStyleLabel");
                    markerOutlineColorLabel = configXML.labels.markeroutlinecolorlabel || getDefaultString("markerOutlineColorLabel");
                    markerOutlineWidthLabel = configXML.labels.markeroutlinewidthlabel || getDefaultString("markerOutlineWidthLabel");
//My Add
                    markerRotationLabel = configXML.labels.markerrotationlabel || "Angle";
//End My Add
                    
                    // lines
                    drawLineLabel = configXML.labels.drawlinelabel || getDefaultString("drawLineLabel");
                    drawFreehandLineLabel = configXML.labels.drawfreehandlinelabel || getDefaultString("drawFreehandLineLabel");
                    lineAlphaLabel = configXML.labels.linealphalabel || getDefaultString("lineAlphaLabel");
                    lineColorLabel = configXML.labels.linecolorlabel || getDefaultString("lineColorLabel");
                    lineStyleLabel = configXML.labels.linestylelabel || getDefaultString("lineStyleLabel");
                    lineWidthLabel = configXML.labels.linewidthlabel || getDefaultString("lineWidthLabel");

                    // polygons
                    drawPolygonLabel = configXML.labels.drawpolygonlabel || getDefaultString("drawPolygonLabel");
                    drawFreehandPolygonLabel = configXML.labels.drawfreehandpolygonlabel || getDefaultString("drawFreehandPolygonLabel");
                    drawRectangleLabel = configXML.labels.drawrectanglelabel || getDefaultString("drawRectangleLabel");
                    drawCircleLabel = configXML.labels.drawcirclelabel || getDefaultString("drawCircleLabel");
                    drawEllipseLabel = configXML.labels.drawellipselabel || getDefaultString("drawEllipseLabel");
                    fillAlphaLabel = configXML.labels.fillalphalabel || getDefaultString("fillAlphaLabel");
                    fillColorLabel = configXML.labels.fillcolorlabel || getDefaultString("fillColorLabel");
                    fillStyleLabel = configXML.labels.fillstylelabel || getDefaultString("fillStyleLabel");
                    fillOutlineColorLabel = configXML.labels.filloutlinecolorlabel || getDefaultString("fillOutlineColorLabel");
                    fillOutlineWidthLabel = configXML.labels.filloutlinewidthlabel || getDefaultString("fillOutlineWidthLabel");
//My Add
                    fillOutlineAlphaLabel = configXML.labels.filloutlinealphalabel || getDefaultString("fillAlphaLabel");
//End My Add

                    clearLabel = configXML.labels.clearlabel || getDefaultString("drawClearLabel");
                    clearFeatureLabel = configXML.labels.clearfeaturelabel || getDefaultString("clearLabel");

                    // measurement labels
                    showmeasurementsLabel = configXML.labels.showmeasurementslabel || getDefaultString("showMeasurementsLabel");
                    distanceUnitsLabel = configXML.labels.distanceunitslabel || getDefaultString("distanceUnitsLabel");
                    areaUnitsLabel = configXML.labels.areaunitslabel || getDefaultString("areaUnitsLabel");
                    areaLabel = configXML.labels.arealabel || getDefaultString("areaLabel");
                    perimeterLabel = configXML.labels.perimeterlabel || getDefaultString("perimeterLabel");
                    lengthLabel = configXML.labels.lengthlabel || getDefaultString("lengthLabel");
//My Add
                    pointsUnitsLabel = configXML.labels.pointunitslabel || "Point Units";
                    
                    //Custom
                    saveLabel = configXML.labels.savelabel || "Save Graphics Layer";
                    openLabel = configXML.labels.openlabel || "Open Saved Graphics Layer";
                    geonumPrecision = configXML.geonumericlabelprecision || 2;
                    dmsnumPrecision = configXML.dmsnumericlabelprecision || 9;
                    dddnumPrecision = configXML.dddnumericlabelprecision || 9;
                    defaultTool = configXML.defaulttool;
//End My Add
                    isMeasuringEnabled = configXML.measure[0] == "true";

                    var distanceList:XMLList = configXML..distanceunit;
                    if (distanceList.length() > 0)
                    {
                        var dName:String;
                        var dAbbr:String;
                        var dConversion:Number;

                        configDistance = new ArrayList();
                        for (var i:int = 0; i < distanceList.length(); i++)
                        {
                            if (distanceList[i].@id[0])
                            {
                                const distanceListId:String = distanceList[i].@id;
                                switch (distanceListId)
                                {
                                    case "ft":
                                    {
                                        dName = getDefaultString("unitsFeet");
                                        dAbbr = getDefaultString('unitsFeetAbbr');
                                        dConversion = 3.2808;
                                        break;
                                    }
                                    case "km":
                                    {
                                        dName = getDefaultString("unitsKilometers");
                                        dAbbr = getDefaultString("unitsKilometersAbbr");
                                        dConversion = 0.001;
                                        break;
                                    }
                                    case "m":
                                    {
                                        dName = getDefaultString("unitsMeters");
                                        dAbbr = getDefaultString("unitsMetersAbbr");
                                        dConversion = 1;
                                        break;
                                    }
                                    case "mi":
                                    {
                                        dName = getDefaultString("unitsMiles");
                                        dAbbr = getDefaultString("unitsMilesAbbr");
                                        dConversion = 0.000621;
                                        break;
                                    }
                                    case "yd":
                                    {
                                        dName = getDefaultString('unitsYards');
                                        dAbbr = getDefaultString('unitsYardsAbbr');
                                        dConversion = 1.0936133;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                dName = distanceList[i];
                                dAbbr = distanceList[i].@abbr;
                                dConversion = Number(distanceList[i].@conversion);
                            }
                            var dUnit:Object = {
                                    name: dName,
                                    abbr: dAbbr,
                                    conversion: dConversion
                                };
                            configDistance.addItem(dUnit);
                        }
                        cboDistance.dataProvider = configDistance;
                    }

                    // area units
                    var areaList:XMLList = configXML..areaunit;
                    if (areaList.length() > 0)
                    {
                        var aName:String;
                        var aAbbr:String;
                        var aConversion:Number;

                        configArea = new ArrayList();
                        for (var j:int = 0; j < areaList.length(); j++)
                        {
                            if (areaList[j].@id[0])
                            {
                                const areaListId:String = areaList[j].@id;
                                switch (areaListId)
                                {
                                    case "ac":
                                    {
                                        aName = getDefaultString("unitsAcres");
                                        aAbbr = getDefaultString("unitsAcresAbbr");
                                        aConversion = 0.00024710538147;
                                        break;
                                    }
                                    case "ha":
                                    {
                                        aName = getDefaultString("unitsHectares");
                                        aAbbr = getDefaultString("unitsHectaresAbbr");
                                        aConversion = 0.0001;
                                        break;
                                    }
                                    case "sq ft":
                                    {
                                        aName = getDefaultString("unitsSquareFeet");
                                        aAbbr = getDefaultString("unitsSquareFeetAbbr");
                                        aConversion = 10.763910417;
                                        break;
                                    }
                                    case "sq km":
                                    {
                                        aName = getDefaultString("unitsSquareKilometers");
                                        aAbbr = getDefaultString("unitsSquareKilometersAbbr");
                                        aConversion = 0.000001;
                                        break;
                                    }
                                    case "sq m":
                                    {
                                        aName = getDefaultString("unitsSquareMeters");
                                        aAbbr = getDefaultString("unitsSquareMetersAbbr");
                                        aConversion = 1;
                                        break;
                                    }
                                    case "sq mi":
                                    {
                                        aName = getDefaultString("unitsSquareMiles");
                                        aAbbr = getDefaultString("unitsSquareMilesAbbr");
                                        aConversion = 0.0000003861021;
                                        break;
                                    }
                                    case "sq yd":
                                    {
                                        aName = getDefaultString("unitsSquareYards");
                                        aAbbr = getDefaultString("unitsSquareYardsAbbr");
                                        aConversion = 1.19599005;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                aName = areaList[j];
                                aAbbr = areaList[j].@abbr;
                                aConversion = Number(areaList[j].@conversion);
                            }
                            var aUnit:Object = {
                                    name: aName,
                                    abbr: aAbbr,
                                    conversion: aConversion
                                };
                            configArea.addItem(aUnit);
                        }
                        cboArea.dataProvider = configArea;
                    }
//My Add
                    var pointList:XMLList = configXML..pointunit;
                    configPoint = new ArrayList();
                    for (i = 0; i < pointList.length(); i++)
                    {
                        var pLabel:String = pointList[i];
                        var pAbbr:String = pointList[i].@abbr;
                        var pWKID:Number = Number(pointList[i].@wkid);
                        var pUnit:Object = 
                            {
                                label: pLabel,
                                abbr: pAbbr,
                                wkid: pWKID
                            }
                        configPoint.addItem(pUnit);
                    }
                    cboPoint.dataProvider = configPoint;
//End My Add
                }

                AppEvent.addListener(AppEvent.DATA_PUBLISH, sharedDataUpdated);
//My Add
                if(defaultTool){
                    activateDefaultDrawTool(defaultTool);
                }
                wTemplate.addTitlebarButton(WIDGET_URL + "i_save.png", saveLabel, saveGraLay,false);
                wTemplate.addTitlebarButton(ICON_URL + "i_folder.png", openLabel, loadGraLay,false);
                drawAC = new ArrayCollection();
                
                if(ViewerContainer.urlConfigParams.draw != null){
                    callLater(drawFromURL,[ViewerContainer.urlConfigParams.draw,ViewerContainer.urlConfigParams.autozoom,ViewerContainer.urlConfigParams.zoompercent]);
                }
                wTemplate.header.addEventListener(MouseEvent.CLICK, DisplayVersion);
//End My Add
            }

            private function initializeFontList():void
            {
                fontList = new ArrayList(prioritizeFontNames(getAvailableFontNames(),
                                                             defaultFontNames));
            }

            private function getAvailableFontNames():Array
            {
                var availableFonts:Array = Font.enumerateFonts(true);
                var allFontNames:Array = [];

                for each (var font:Font in availableFonts)
                {
                    allFontNames.push(font.fontName);
                }

                const localeBasedSorter:Sort = new Sort();
                localeBasedSorter.setStyle('locale', resourceManager.localeChain[0]);
                localeBasedSorter.sort(allFontNames);

                return allFontNames;
            }

            public function get defaultFontNames():Array
            {
                var fontNames:Array = [ getDefaultString('textFont1'),
                                        getDefaultString('textFont2'),
                                        getDefaultString('textFont3'),
                                        getDefaultString('textFont4'),
                                        getDefaultString('textFont5'),
                                        getDefaultString('textFont6')];

                return fontNames.filter(validFontName);
            }

            private function validFontName(fontName:String, index:int, array:Array):Boolean
            {
                return Boolean(fontName);
            }

            private function prioritizeFontNames(fontNames:Array, preferredFontNames:Array):Array
            {
                var prioritizedFontNames:Array = preferredFontNames.concat();
                var isFontNameUnique:Boolean;

                for each (var fontName:String in fontNames)
                {
                    isFontNameUnique = (preferredFontNames.indexOf(fontName) == -1);
                    if (isFontNameUnique)
                    {
                        prioritizedFontNames.push(fontName);
                    }
                }

                return prioritizedFontNames;
            }

            private function sharedDataUpdated(event:AppEvent):void
            {
                var data:Object = event.data;

                if (data.key == "Deactivate_DrawTool")
                {
                    setMapAction(null, null, null, null);
                    stopEditing();
                    if (selectedDrawingIcon)
                    {
                        selectedDrawingIcon.filters = [];
                        selectedDrawingIcon = null;
                    }
                }
            }

            private function stopEditing():void
            {
                isEditing = false;
                if (editGraphic)
                {
                    editGraphic.checkForMouseListeners = false;
                }
                editGraphic = null;
                lastActiveEditType = "none";
                editTool.deactivate();
            }

//My Add
            private function activateDefaultDrawTool(drawTool:String):void
            {
                addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets
                
                var img:FocusableImage;
                for (var ele:int = 0; ele<drawImageGroup.numElements; ele++){
                    img = drawImageGroup.getElementAt(ele) as FocusableImage;
                    if (img.name == drawTool){
                        break;
                    }
                }
                
                // apply glow
                selectedDrawingIcon = img;
                clearSelectionFilter();
                selectedDrawingIcon.filters = [ glowFilter ];
	
                finishDrawing = showMeasurements = isEditing = false;
                
                frmDraw.visible = true;
                showMeasurements = false;
                
                stopEditing();
                
                drawType = selectedDrawingIcon.name;
                switch (drawType)
                {
                    case DrawTool.MAPPOINT:
                    {
                        drawingPolygon = drawingLine = false;
                        addingText = selectedDrawingIcon.id == "text";
                        drawingPoint = !addingText;
                        showMeasurements = drawingPoint = !addingText;
                        PointXY = true;
                        drawMode = addingText ? TEXT_MODE : null;
                        drawStatus = (drawMode == TEXT_MODE) ? addTextLabel : drawPointLabel;
                        setMapAction(drawType, drawStatus, null, map_drawEndHandler);
                        break;
                    }
                    case DrawTool.POLYLINE:
                    {
                        drawingPoint = addingText = drawingPolygon = PointXY = false;
                        drawingLine = showMeasurements = true;
                        drawStatus = drawLineLabel;
                        setMapAction(drawType, drawStatus, lineSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.FREEHAND_POLYLINE:
                    {
                        drawingPoint = addingText = drawingPolygon = PointXY = false;
                        drawingLine = showMeasurements = true;
                        drawStatus = drawFreehandLineLabel;
                        setMapAction(drawType, drawStatus, lineSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.EXTENT:
                    {
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
                        drawStatus = drawRectangleLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.CIRCLE:
                    {
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
                        drawStatus = drawCircleLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.ELLIPSE:
                    {
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
                        drawStatus = drawEllipseLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.POLYGON:
                    {
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
                        drawStatus = drawPolygonLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.FREEHAND_POLYGON:
                    {
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
                        drawStatus = drawFreehandPolygonLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                }
            }
//End My Add
            private function activateDrawTool(event:MouseEvent):void
            {
                addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets

                // apply glow
                selectedDrawingIcon = FocusableImage(event.currentTarget);
                clearSelectionFilter();
                selectedDrawingIcon.filters = [ glowFilter ];
//My Add	
                finishDrawing = showMeasurements = isEditing = false;
//End My Add

                frmDraw.visible = true;
                showMeasurements = false;

                stopEditing();

                drawType = selectedDrawingIcon.name;
                switch (drawType)
                {
                    case DrawTool.MAPPOINT:
                    {
                        drawingPolygon = drawingLine = false;
                        addingText = selectedDrawingIcon.id == "text";
                        drawingPoint = !addingText;
//My Add
                        showMeasurements = drawingPoint = !addingText;
                        PointXY = true;
//End My Add
                        drawMode = addingText ? TEXT_MODE : null;
                        drawStatus = (drawMode == TEXT_MODE) ? addTextLabel : drawPointLabel;
                        setMapAction(drawType, drawStatus, null, map_drawEndHandler);
                        break;
                    }
                    case DrawTool.POLYLINE:
                    {
//My Change
                        drawingPoint = addingText = drawingPolygon = PointXY = false;
                        drawingLine = showMeasurements = true;
//End My Change
                        drawStatus = drawLineLabel;
                        setMapAction(drawType, drawStatus, lineSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.FREEHAND_POLYLINE:
                    {
//My Change
                        drawingPoint = addingText = drawingPolygon = PointXY = false;
                        drawingLine = showMeasurements = true;
//End My Change
                        drawStatus = drawFreehandLineLabel;
                        setMapAction(drawType, drawStatus, lineSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.EXTENT:
                    {
//My Change
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
//End My Change
                        drawStatus = drawRectangleLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.CIRCLE:
                    {
//My Change
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
//End My Change
                        drawStatus = drawCircleLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.ELLIPSE:
                    {
//My Change
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
//End My Change
                        drawStatus = drawEllipseLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.POLYGON:
                    {
//My Change
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
//End My Change
                        drawStatus = drawPolygonLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                    case DrawTool.FREEHAND_POLYGON:
                    {
//My Change
                        addingText = drawingPoint = drawingLine = PointXY = false;
                        drawingPolygon = showMeasurements = true;
//End My Change
                        drawStatus = drawFreehandPolygonLabel;
                        setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, map_drawUpdateHandler, false, false);
                        break;
                    }
                }
            }

            private function clear():void
            {
                graphicsLayer.clear();
                stopEditing();
                updateHasDrawnGraphics();
                clearGraphicToMeasurementGraphic();
            }

            private function updateHasDrawnGraphics():void
            {
                hasDrawnGraphics = graphicsLayer.numGraphics > 0;
            }

            private function clearGraphicToMeasurementGraphic():void
            {
                for (var key:Object in graphicToMeasurementGraphic)
                {
                    delete graphicToMeasurementGraphic[key];
                }
            }

            private function clearSelectionFilter():void
            {
                for (var i:int = 0; i < drawImageGroup.numChildren; i++)
                {
                    if (drawImageGroup.getChildAt(i).filters && drawImageGroup.getChildAt(i).filters.length > 0)
                    {
                        if (!(selectedDrawingIcon && drawImageGroup.getChildAt(i) === selectedDrawingIcon))
                        {
                            drawImageGroup.getChildAt(i).filters = [];
                        }
                    }
                }
            }

            private function getMeasurementGraphic(graphic:Graphic):Graphic
            {
                return graphicToMeasurementGraphic[graphic];
            }

            private function map_drawUpdateHandler(event:DrawEvent):void
            {
//My Add
                if(!disableLiveMeasure){
//End My Add
                    lastDrawnGraphic = event.graphic;
                    if (isMeasuringEnabled)
                    {
                        if (!lastDrawnGraphic.hasEventListener(GraphicEvent.GRAPHIC_REMOVE))
                        {
                            lastDrawnGraphic.graphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, drawnGraphic_graphicRemoveHandler, false, 0, true);
                        }
                        measureGraphicClientSide(lastDrawnGraphic);
                    }
                }
            }

            private function drawnGraphic_graphicRemoveHandler(event:GraphicEvent):void
            {
                const measurementGraphic:Graphic = getMeasurementGraphic(event.graphic);
                if (measurementGraphic)
                {
                    graphicsLayer.remove(measurementGraphic);
                    clearMeasurementGraphic(event.graphic);
                }
            }

            private function clearMeasurementGraphic(graphic:Graphic):void
            {
                graphicToMeasurementGraphic[graphic] = null;
            }

            private function map_drawEndHandler(event:DrawEvent):void
            {
//My Add
                finishDrawing = true;
//End My Add
                selectedDrawingIcon = null;
                clearSelectionFilter();
                event.target.deactivate();

                lastDrawnGraphic = event.graphic;

                var customContextMenu:ContextMenu = new ContextMenu();
                customContextMenu.hideBuiltInItems();
                var menuItem:ContextMenuItem = new ContextMenuItem(clearFeatureLabel);
                menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, menuItem_contextMenuDeleteHandler);
                customContextMenu.customItems.push(menuItem);
                lastDrawnGraphic.contextMenu = customContextMenu;

                lastDrawnGraphic.addEventListener(MouseEvent.MOUSE_DOWN, graphic_mouseDownHandler, false, 0, true);
//My Add
                lastDrawnGraphic.attributes = {labeled: chkMeasurements.selected, wkid: map.spatialReference.wkid};
//End My Add
                lastDrawnGraphic.checkForMouseListeners = false;
                graphicsLayer.add(lastDrawnGraphic);

                var geom:Geometry = lastDrawnGraphic.geometry;
                switch (geom.type)
                {
                    case Geometry.MAPPOINT:
                    {
                        if (drawMode == TEXT_MODE)
                        {
                            var textSymbol:TextSymbol = new TextSymbol(txtLabel.text);
                            var txtFormat:TextFormat = new TextFormat(fontNameSelection.selectedItem, numTextSize.value, cpText.selectedColor, bold.selected, italic.selected, underline.selected);
                            textSymbol.textFormat = txtFormat;
//My Add
                            textSymbol.angle = numTextRotation.value;
                            if(AddTextHaloSel.selected){
                                lastDrawnGraphic.filters = [measurementBorderFilter];
                            }
//End My Add
                            lastDrawnGraphic.symbol = textSymbol;
                        }
                        else
                        {
//My Change and Add Change is to the angle of the simple marker symbol
                            lastDrawnGraphic.symbol = new SimpleMarkerSymbol(markerStyle.selectedItem.style, numMarkerSize.value, cpMarker.selectedColor, numMarkerAlpha.value, 0, 0, numMarkerAngle.value, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, cpMarkerOutline.selectedColor, 1, numMarkerOutlineWidth.value));
                            lastDrawnGraphic.attributes.wkid = cboPoint.selectedItem.wkid;
                            lastDrawnGraphic.attributes.abbr = cboPoint.selectedItem.abbr;
                            var projParams:ProjectParameters = new ProjectParameters();
                            projParams.geometries = [geom];
                            projParams.outSpatialReference = new SpatialReference(cboPoint.selectedItem.wkid);
                            geometryService.project(projParams);
                            measurePt = geom as MapPoint;
                            updateMeasureLabelPosition(lastDrawnGraphic);
//End My Add
                        }
                        break;
                    }
                    case Geometry.POLYLINE:
                    {
//My Change
                        lastDrawnGraphic.symbol = new SimpleLineSymbol(lineStyle.selectedItem.style, cpLine.selectedColor, numLineAlpha.value, numLineWidth.value);
                        updateMeasureLabelPosition(lastDrawnGraphic);
                        measureGeometry(lastDrawnGraphic.geometry);
                        break;
//End My Change
                    }
                    case Geometry.POLYGON:
                    {
//My Change
                        lastDrawnGraphic.symbol = new SimpleFillSymbol(fillStyle.selectedItem.style, cpFill.selectedColor, numFillAlpha.value, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, cpFillOutline.selectedColor, numFillOutlineAlpha.value, numFillOutlineWidth.value));
                        
                        var polygon:Polygon = geom as Polygon;
                        if (GeometryUtil.polygonSelfIntersecting(polygon))
                        {
                            geometryService.simplify([ polygon ]);
                        }
                        else
                        {
                            updateMeasureLabelPosition(lastDrawnGraphic);
                            measureGeometry(lastDrawnGraphic.geometry);
                        }
//End My Change
                        break;
                    }
                    case Geometry.EXTENT:
                    {
                        lastDrawnGraphic.symbol = new SimpleFillSymbol(fillStyle.selectedItem.style, cpFill.selectedColor, numFillAlpha.value, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, cpFillOutline.selectedColor, 1, numFillOutlineWidth.value));
//My Change
                        
                        updateMeasureLabelPosition(lastDrawnGraphic);
                        // convert it to a polygon before project for more accururate result
                        measureGeometry(lastDrawnGraphic.geometry);
//End My Change
                        break;
                    }
                }

                updateHasDrawnGraphics();
                moveMeasurementGraphicToTop(lastDrawnGraphic);
            }

            private function menuItem_contextMenuDeleteHandler(event:ContextMenuEvent):void
            {
                const drawnGraphic:Graphic = Graphic(event.contextMenuOwner);
                graphicsLayer.remove(drawnGraphic);
                // also remove measurement label if any
                graphicsLayer.remove(getMeasurementGraphic(drawnGraphic));
                stopEditing();
                updateHasDrawnGraphics();
            }

            protected function graphic_mouseDownHandler(event:MouseEvent):void
            {
                var graphic:Graphic = event.currentTarget as Graphic;
                graphic.removeEventListener(MouseEvent.MOUSE_DOWN, graphic_mouseDownHandler);
                graphic.addEventListener(MouseEvent.MOUSE_MOVE, graphic_mouseMoveHandler);
                graphic.addEventListener(MouseEvent.MOUSE_UP, graphic_mouseUpHandler);
            }

            protected function graphic_mouseMoveHandler(event:MouseEvent):void
            {
                var graphic:Graphic = event.currentTarget as Graphic;
                graphic.removeEventListener(MouseEvent.MOUSE_MOVE, graphic_mouseMoveHandler);
                graphic.removeEventListener(MouseEvent.MOUSE_UP, graphic_mouseUpHandler);
                graphic.addEventListener(MouseEvent.MOUSE_DOWN, graphic_mouseDownHandler);
            }

            protected function graphic_mouseUpHandler(event:MouseEvent):void
            {
                var graphic:Graphic = event.currentTarget as Graphic;
                graphic.removeEventListener(MouseEvent.MOUSE_MOVE, graphic_mouseMoveHandler);
                graphic.removeEventListener(MouseEvent.MOUSE_UP, graphic_mouseUpHandler);
                graphic.addEventListener(MouseEvent.MOUSE_DOWN, graphic_mouseDownHandler);

                toggleEditing(graphic);
            }

            private function toggleEditing(currentGraphic:Graphic):void
            {
                if (editGraphic !== currentGraphic)
                {
                    stopEditing();
                    editGraphic = currentGraphic;
                    lastActiveEditType = "none"
                }

                if (editGraphic.geometry is Polyline || editGraphic.geometry is Polygon)
                {
                    if (lastActiveEditType == "none")
                    {
                        lastActiveEditType = "moveEditVertices";
                        startEditing(EditTool.MOVE | EditTool.EDIT_VERTICES, editGraphic);
                        showMoveCursor();
                    }
                    else if (lastActiveEditType == "moveEditVertices")
                    {
                        lastActiveEditType = "moveRotateScale";
                        startEditing(EditTool.MOVE | EditTool.SCALE | EditTool.ROTATE, editGraphic);
                        showMoveCursor();
                    }
                    else if (lastActiveEditType == "moveRotateScale")
                    {
                        stopEditing();
                    }
                }
                else if (editGraphic.geometry is Extent)
                {
                    if (lastActiveEditType == "none")
                    {
                        lastActiveEditType = "moveScale";
                        startEditing(EditTool.MOVE | EditTool.SCALE, editGraphic);
                        showMoveCursor();
                    }
                    else
                    {
                        stopEditing();
                    }
                }
                else
                {
                    if (lastActiveEditType == "none")
                    {
                        lastActiveEditType = "moveEditVertices";
                        startEditing(EditTool.EDIT_VERTICES | EditTool.MOVE, editGraphic);
                        showMoveCursor();
                    }
                    else
                    {
                        stopEditing();
                    }
                }

                removeEditToolEventListeners();
                map.removeEventListener(MouseEvent.MOUSE_DOWN, map_mouseDownHandler);

                if (editGraphic)
                {
                    addEditToolEventListeners();
                    moveMeasurementGraphicToTop(editGraphic);
                    map.addEventListener(MouseEvent.MOUSE_DOWN, map_mouseDownHandler);
                }
            }

            private function startEditing(editMode:Number, graphic:Graphic):void
            {
                isEditing = true;
                graphic.checkForMouseListeners = true;
                editTool.activate(editMode, [ graphic ]);
            }

            private function showMoveCursor():void
            {
                var hasMoveCursorIdBeenSet:Boolean = (moveCursorIconId > 0);
                if (hasMoveCursorIdBeenSet)
                {
                    CursorManager.removeCursor(moveCursorIconId);
                }

                moveCursorIconId = CursorManager.setCursor(
                    moveCursorIcon, CursorManagerPriority.HIGH, -16, -16);
            }

            private function moveMeasurementGraphicToTop(drawnGraphic:Graphic):void
            {
                const measurementGraphic:Graphic = getMeasurementGraphic(drawnGraphic);
                if (measurementGraphic)
                {
                    measurementGraphic.graphicsLayer.moveToTop(measurementGraphic);
                }
            }

            private function removeEditToolEventListeners():void
            {
                editTool.removeEventListener(EditEvent.GRAPHICS_MOVE_START, editTool_editStartHandler);
                editTool.removeEventListener(EditEvent.GRAPHIC_SCALE_START, editTool_editStartHandler);
                editTool.removeEventListener(EditEvent.GRAPHIC_ROTATE_START, editTool_editStartHandler);

                editTool.removeEventListener(EditEvent.GRAPHIC_ROTATE, editTool_UpdateHandler);
                editTool.removeEventListener(EditEvent.GRAPHIC_SCALE, editTool_UpdateHandler);
                editTool.removeEventListener(EditEvent.GRAPHICS_MOVE, editTool_UpdateHandler);
                editTool.removeEventListener(EditEvent.VERTEX_MOVE, editTool_UpdateHandler);
                editTool.removeEventListener(EditEvent.GHOST_VERTEX_MOUSE_MOVE, editTool_UpdateHandler);

                editTool.removeEventListener(EditEvent.VERTEX_ADD, editTool_editStopHandler);
                editTool.removeEventListener(EditEvent.VERTEX_DELETE, editTool_editStopHandler);
                editTool.removeEventListener(EditEvent.VERTEX_MOVE_STOP, editTool_editStopHandler);
                editTool.removeEventListener(EditEvent.GRAPHICS_MOVE_STOP, editTool_editStopHandler);
                editTool.removeEventListener(EditEvent.GRAPHIC_ROTATE_STOP, editTool_editStopHandler);
                editTool.removeEventListener(EditEvent.GRAPHIC_SCALE_STOP, editTool_editStopHandler);
            }

            private function map_mouseDownHandler(event:MouseEvent):void
            {
                map.removeEventListener(MouseEvent.MOUSE_DOWN, map_mouseDownHandler);
                map.addEventListener(MouseEvent.MOUSE_UP, map_mouseUpHandler);
                map.addEventListener(MouseEvent.MOUSE_MOVE, map_mouseMoveHandler);
            }

            private function map_mouseUpHandler(event:MouseEvent):void
            {
//My Add
                if(event.target is FTETextField){
                    if(event.target.parent !== editGraphic){
                        map.removeEventListener(MouseEvent.MOUSE_UP, map_mouseUpHandler);
                        map.removeEventListener(MouseEvent.MOUSE_MOVE, map_mouseMoveHandler);
                        
                        stopEditing();
                    }else{
                        return;
                    }
                }
//End My Add
                if (event.target !== editGraphic)
                {
                    map.removeEventListener(MouseEvent.MOUSE_UP, map_mouseUpHandler);
                    map.removeEventListener(MouseEvent.MOUSE_MOVE, map_mouseMoveHandler);

                    stopEditing();
                }
            }

            private function map_mouseMoveHandler(event:MouseEvent):void
            {
                map.addEventListener(MouseEvent.MOUSE_DOWN, map_mouseDownHandler);
                map.removeEventListener(MouseEvent.MOUSE_UP, map_mouseUpHandler);
                map.removeEventListener(MouseEvent.MOUSE_MOVE, map_mouseMoveHandler);
            }

            private function addEditToolEventListeners():void
            {
                editTool.addEventListener(EditEvent.GRAPHICS_MOVE_START, editTool_editStartHandler);
                editTool.addEventListener(EditEvent.GRAPHIC_SCALE_START, editTool_editStartHandler);
                editTool.addEventListener(EditEvent.GRAPHIC_ROTATE_START, editTool_editStartHandler);

                editTool.addEventListener(EditEvent.GRAPHIC_ROTATE, editTool_UpdateHandler);
                editTool.addEventListener(EditEvent.GRAPHIC_SCALE, editTool_UpdateHandler);
                editTool.addEventListener(EditEvent.GRAPHICS_MOVE, editTool_UpdateHandler);
                editTool.addEventListener(EditEvent.VERTEX_MOVE, editTool_UpdateHandler);
                editTool.addEventListener(EditEvent.GHOST_VERTEX_MOUSE_MOVE, editTool_UpdateHandler);

                editTool.addEventListener(EditEvent.VERTEX_ADD, editTool_editStopHandler);
                editTool.addEventListener(EditEvent.VERTEX_DELETE, editTool_editStopHandler);
                editTool.addEventListener(EditEvent.VERTEX_MOVE_STOP, editTool_editStopHandler);
                editTool.addEventListener(EditEvent.GRAPHICS_MOVE_STOP, editTool_editStopHandler);
                editTool.addEventListener(EditEvent.GRAPHIC_ROTATE_STOP, editTool_editStopHandler);
                editTool.addEventListener(EditEvent.GRAPHIC_SCALE_STOP, editTool_editStopHandler);
            }

            private function editTool_editStopHandler(event:EditEvent):void
            {
                if (!(event.graphic || event.graphics))
                {
                    return;
                }

                var editedGraphic:Graphic = event.graphic ? event.graphic : event.graphics[0];

                if (map.wrapAround180)
                {
                    normalizeGraphicGeometry(editedGraphic);
                }
                else if (getMeasurementGraphic(editedGraphic))
                {
                    recalculate(editedGraphic);
                }
            }

            private function normalizeGraphicGeometry(graphic:Graphic):void
            {
                // normalize
                GeometryUtil.normalizeCentralMeridian([ graphic.geometry ], GeometryServiceSingleton.instance, new AsyncResponder(getNormalizedGeometryFunction, faultFunction));
                function getNormalizedGeometryFunction(item:Object, token:Object = null):void
                {
                    var normalizedGeometries:Array = item as Array;
                    graphic.geometry = normalizedGeometries[0];
                    if (graphic.geometry is Polyline || graphic.geometry is Polygon)
                    {
                        if (lastActiveEditType == "moveScale")
                        {
                            lastActiveEditType = "moveEditVertices"; // after normalization, if extent crosses the dateline, it is converted to a polygon
                        }
                        if (lastActiveEditType == "moveEditVertices")
                        {
                            startEditing(EditTool.MOVE | EditTool.EDIT_VERTICES, graphic);
                        }
                        else if (lastActiveEditType == "moveRotateScale")
                        {
                            startEditing(EditTool.MOVE | EditTool.SCALE | EditTool.ROTATE, graphic);
                        }
                    }
                    else if (graphic.geometry is Extent)
                    {
                        if (lastActiveEditType == "moveScale")
                        {
                            startEditing(EditTool.MOVE | EditTool.SCALE, graphic);
                        }
                    }                  
                    else
                    {
                        if (lastActiveEditType == "moveEditVertices")
                        {
                            startEditing(EditTool.EDIT_VERTICES | EditTool.MOVE, graphic);
                        }
                    }
                    if (getMeasurementGraphic(graphic))
                    {
                        recalculate(graphic);
                    }
                }
                function faultFunction(fault:Fault, token:Object = null):void
                {
                    dispatchEvent(new FaultEvent(FaultEvent.FAULT, false, false, fault));
                }
            }

            private function recalculate(graphic:Graphic):void
            {
                var gwkid:Number = NaN;
//My Add
                if(graphic.geometry is MapPoint){
                    gwkid = graphic.attributes.wkid;
                    updateMeasureLabelPosition(graphic);
                }
//End My Add Start My Change
                measureGeometry(graphic.geometry, gwkid);
//End My Change
                moveMeasurementGraphicToTop(graphic);
            }

            private function measureGeometry(geom:Geometry, gwkid:Number = NaN):void
            {
                if(geom.type == Geometry.MAPPOINT && isNaN(gwkid) == false && gwkid != map.spatialReference.wkid){
                    var projParams:ProjectParameters = new ProjectParameters();
                    projParams.geometries = [geom];
                    projParams.outSpatialReference = new SpatialReference(gwkid);
                    geometryService.project(projParams);
                    return;
                }else if(geom.type == Geometry.MAPPOINT){
                    calculateAreasAndLengths(geom);
                    return;
                }
                var geomSR:SpatialReference = geom.spatialReference;
                if (geomSR.wkid == EPSG_GEOGRAPHIC || geomSR.isWebMercator())
                {
                    calculateAreasAndLengths(geom);
                }
                else
                {
                    var geographicSpatialReference:SpatialReference = new SpatialReference(EPSG_GEOGRAPHIC);
                    const projectParameters:ProjectParameters = new ProjectParameters;
                    projectParameters.geometries = [ geom ];
                    projectParameters.outSpatialReference = geographicSpatialReference;
                    geometryService.project(projectParameters);
                }
            }

            private function geometryService_projectCompleteHandler(event:GeometryServiceEvent):void
            {
                var geom:Geometry = (event.result as Array)[0];
                calculateAreasAndLengths(geom);
            }

            private function calculateAreasAndLengths(geom:Geometry):void
            {
                switch (geom.type)
                {
//My Add
                    case Geometry.MAPPOINT:
                    {
                        var graphic:Graphic = isEditing ? editGraphic : lastDrawnGraphic;
                        var pointLabel:String;
                        var pPnt:MapPoint = geom as MapPoint;
                        if (graphic.attributes.wkid == "4326"){
                            numPrecision = dddnumPrecision
                        }else{
                            numPrecision = geonumPrecision
                        }
                        
                        if (graphic.attributes.wkid == "4326" && graphic.attributes.abbr == "wgs84dms"){
                            if (chkMeasurements.selected){
                                addDrawLabel(deg_to_dms(Math.abs(pPnt.x)) + ", " + deg_to_dms(Math.abs(pPnt.y)), graphic);
                            }
                            pointLabel = "X: " + deg_to_dms(Math.abs(pPnt.x)) + ", Y: " + deg_to_dms(Math.abs(pPnt.y));
                        }else{
                            if (chkMeasurements.selected){
                                addDrawLabel(numFormatter2.format(pPnt.x) + ", " + numFormatter2.format(pPnt.y), graphic);
                            }
                            pointLabel = "X: " + numFormatter2.format(pPnt.x) + ", Y: " + numFormatter2.format(pPnt.y);
                        }
                        var cMenu:ContextMenu = graphic.contextMenu;
                        cMenu.hideBuiltInItems();
                        if(cMenu.customItems.length == 1){
                            var menuItem2:ContextMenuItem = new ContextMenuItem(pointLabel);
                            cMenu.customItems.push(menuItem2);
                            graphic.contextMenu = cMenu;
                        }else if(cMenu.customItems.length == 2){
                            var menuItem3:ContextMenuItem = cMenu.customItems[1];
                            menuItem3.caption = pointLabel;
                            graphic.contextMenu = cMenu;
                        }
                        updateMeasureLabelPosition(graphic);
                        break;
                    }
//End My Add
                    case Geometry.POLYLINE:
                    {
                        var polyline:Polyline = Polyline(geom);

                        const isValidPolyline:Boolean =
                            polyline.paths
                            && polyline.paths.length > 0
                            && polyline.paths[0].length > 1;

                        if (isValidPolyline)
                        {
                            calculatePolylineLengths(polyline);
                        }
                        break;
                    }
                    case Geometry.POLYGON:
                    {
                        var polygon:Polygon = Polygon(geom);

                        const isValidPolygon:Boolean =
                            polygon.rings
                            && polygon.rings.length > 0
                            && polygon.rings[0].length > 3;

                        if (isValidPolygon)
                        {
                            if (polygon && GeometryUtil.polygonSelfIntersecting(polygon))
                            {
                                hideMeasurementLabel(lastDrawnGraphic);
                                return;
                            }

                            calculatePolygonAreasAndLengths(polygon);
                        }
                        break;
                    }
                    case Geometry.EXTENT:
                    {
                        var extent:Extent = Extent(geom);
                        calculatePolygonAreasAndLengths(extent.toPolygon()); //convert it to polygon for measurement
                        break;
                    }
                }
            }
            
//My Add
            private function deg_to_dms ( degfloat:Number ):String
            {
                //Input must be non-negative:
                if (degfloat < 0){
                    return "error";
                }
                
                //Compute degrees, minutes and seconds:
                var deg:int = int(degfloat);
                var minfloat:Number = 60 * ( degfloat - deg );
                var min:int = int( minfloat );
                var secfloat:Number = 60 * ( minfloat - min );
                
                var rString:String = "";
                rString = deg + "" + min + "'" + secfloat.toFixed(dmsnumPrecision) + "''";
                return rString;
            }
            
            private function drawFromURL(value:String, autozoom:Boolean = true, zoompercent:Number = 1.2):void
            {
                autoZoom = autozoom;
                zoomPercent = zoompercent;
                const urlLoader:URLLoader = new URLLoader();
                urlLoader.dataFormat = URLLoaderDataFormat.BINARY;
                urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, urldoNothing);
                urlLoader.addEventListener(IOErrorEvent.IO_ERROR, urldoNothing);
                urlLoader.addEventListener(Event.COMPLETE, onLoadComplete2);
                const request:URLRequest = new URLRequest(value);
                request.method = URLRequestMethod.POST;
                urlLoader.load(request);
                
                function urldoNothing(event:Event):void
                {
                    const loader:URLLoader = event.target as URLLoader;
                    loader.close();
                }
            }
//End My Add

            private function calculatePolylineLengths(polyline:Polyline):void
            {
                var polylineToMeasure:Polyline;

                var lengths:Array;
                if (drawType == DrawTool.POLYLINE)
                {
                    var normalizedPolyline:Polyline;
                    if (map.wrapAround180)
                    {
                        GeometryUtil.normalizeCentralMeridian([ polyline ], null, new AsyncResponder(getNormalizedGeometryFunction, null));
                        function getNormalizedGeometryFunction(item:Object, token:Object = null):void
                        {
                            normalizedPolyline = (item as Array)[0] as Polyline;
                        }
                    }
                    else
                    {
                        normalizedPolyline = polyline;
                    }
                    polylineToMeasure = getPolylineToMeasure(normalizedPolyline);

                    var oldPoints:Array = [];
                    var newPaths:Array = [];
                    for each (var path:Array in polylineToMeasure.paths)
                    {
                        var newPath:Array = [];

                        var p0:MapPoint = path[0];
                        newPath.push(p0);
                        for (var n:int = 1; n < path.length; n++)
                        {
                            var pn:MapPoint = path[n];

                            const distance:Number = Math.sqrt(Math.pow(pn.x - p0.x, 2) + Math.pow(pn.y - p0.y, 2));
                            const dx:Number = pn.x - p0.x;
                            const dy:Number = pn.y - p0.y;
                            for (var k:int = 1; k < distance; k++)
                            {
                                const ratio:Number = k / distance;
                                const newPointX:Number = p0.x + ratio * dx;
                                const newPointY:Number = p0.y + ratio * dy;
                                const newMapPoint:MapPoint = new MapPoint(newPointX, newPointY);
                                newPath.push(newMapPoint);
                            }
                            newPath.push(pn);
                            p0 = pn;
                        }
                        newPaths.push(newPath);
                    }
                    var newPolyline:Polyline = new Polyline(newPaths);
                    lengths = GeometryUtil.geodesicLengths([ newPolyline ], Units.METERS);
                }
                else
                {
                    polylineToMeasure = getPolylineToMeasure(polyline);
                    lengths = GeometryUtil.geodesicLengths([ polylineToMeasure ], Units.METERS);
                }

                var abbrDist:String = cboDistance.selectedItem.abbr;
                var convDist:Number = cboDistance.selectedItem.conversion;
                var length:Number = lengths[0] * convDist;

                if (length == 0)
                {
                    return;
                }

                var label:String = createLengthsLabel(length, abbrDist);

                var graphic:Graphic = isEditing ? editGraphic : lastDrawnGraphic;

                addDrawLabel(label, graphic);
//My Add
                var cMenu:ContextMenu = graphic.contextMenu;
                if(!cMenu){
                    cMenu = new ContextMenu();
                }
                cMenu.hideBuiltInItems();
                if(cMenu.customItems.length == 1){
                    var menuItem2:ContextMenuItem = new ContextMenuItem(lengthLabel + " " +  numFormatter.format(length) + " " + abbrDist);
                    cMenu.customItems.push(menuItem2);
                    graphic.contextMenu = cMenu;
                }
//End My Add
                updateMeasureLabelPosition(graphic);
            }

            private function getPolylineToMeasure(polyline:Polyline):Polyline
            {
                var result:Polyline;

                var polylineSR:SpatialReference = polyline.spatialReference;
                if (polylineSR.wkid == EPSG_GEOGRAPHIC)
                {
                    result = polyline;
                }
                else if (polylineSR.isWebMercator())
                {
                    result = WebMercatorUtil.webMercatorToGeographic(polyline) as Polyline;
                }

                return result;
            }

            private function createLengthsLabel(length:Number, lengthAbbrev:String):String
            {
                return lengthLabel + " " + numFormatter.format(length) + " " + lengthAbbrev;
            }

            private function calculatePolygonAreasAndLengths(polygon:Polygon):void
            {
                var polygonToMeasure:Polygon;

                var polygonSR:SpatialReference = polygon.spatialReference;
                if (polygonSR.wkid == EPSG_GEOGRAPHIC)
                {
                    polygonToMeasure = polygon;
                }
                else if (polygonSR.isWebMercator())
                {
                    polygonToMeasure = WebMercatorUtil.webMercatorToGeographic(polygon) as Polygon;
                }

                var lengths:Array = GeometryUtil.geodesicLengths([ new Polyline(polygonToMeasure.rings)], Units.METERS);
                var areas:Array = GeometryUtil.geodesicAreas([ polygonToMeasure ], Units.SQUARE_METERS);

                var abbrArea:String = cboArea.selectedItem.abbr;
                var convArea:Number = cboArea.selectedItem.conversion;
                var abbrDist:String = cboDistance.selectedItem.abbr;
                var convDist:Number = cboDistance.selectedItem.conversion;
                var area:Number = Math.abs(areas[0] * convArea);
                var length:Number = lengths[0] * convDist;

                if (area == 0 && length == 0)
                {
                    return;
                }

                var label:String = area > 0 ?
                    createAreasAndLengthsLabel(area, abbrArea, length, abbrDist) :
                    createLengthsLabel(length, abbrDist);

                var graphic:Graphic = isEditing ? editGraphic : lastDrawnGraphic;
                addDrawLabel(label, graphic);
//My Add
                var cMenu:ContextMenu = graphic.contextMenu;
                if(!cMenu){
                    cMenu = new ContextMenu();
                }
                cMenu.hideBuiltInItems();
                if(cMenu.customItems.length>1){
                    cMenu.customItems.splice(1,cMenu.customItems.length);
                }
                if(cMenu.customItems.length == 1){
                    var menuItem2:ContextMenuItem = new ContextMenuItem(areaLabel + " " + numFormatter.format(area) + " " + abbrArea);
                    var menuItem3:ContextMenuItem = new ContextMenuItem(perimeterLabel + " " +  numFormatter.format(length) + " " + abbrDist);
                    cMenu.customItems.push(menuItem2);
                    cMenu.customItems.push(menuItem3);
                    graphic.contextMenu = cMenu;
                }
//End My Add
                updateMeasureLabelPosition(graphic);
            }

            private function createAreasAndLengthsLabel(area:Number, areaAbbrev:String, length:Number, lengthAbbrev:String):String
            {
                return areaLabel + " " + numFormatter.format(area) + " " + areaAbbrev +
                    "\n" + perimeterLabel + " " + numFormatter.format(length) + " " + lengthAbbrev;
            }

            private function addDrawLabel(label:String, graphic:Graphic):void
            {
                if (!chkMeasurements.selected){
                    return;
                }
                var measurementGraphic:Graphic = getMeasurementGraphic(graphic);
                if (measurementGraphic)
                {
                    (measurementGraphic.symbol as TextSymbol).text = label;
                }
                else
                {
                    measurementGraphic = new Graphic(measurePt);
                    if (!measurementGraphic.symbol)
                    {
                        var txtSym:TextSymbol = new TextSymbol(label);
                        txtSym.yoffset = 8;
                        //var txtFormat:TextFormat = new TextFormat("Arial", 12, 0x000000, true); // black label
//My Add
                        var labeled:Boolean = false;
                        var txtFormat:TextFormat = new TextFormat(fontNameSelection2.selectedItem, numTextSize2.value, cpText2.selectedColor, bold2.selected, italic2.selected, underline2.selected);
//End My Add
                        txtSym.textFormat = txtFormat;
//My Add
                        txtSym.angle = numTextRotation.value;
//End My Add
                        measurementGraphic.symbol = txtSym;
                    }

                    // also remove measurement label if any
                    measurementGraphic.mouseEnabled = false;
                    measurementGraphic.mouseChildren = false;
                    measurementGraphic.filters = [ measurementBorderFilter ];
//My Add
                    measurementGraphic.name = graphic.id;
//End My Add
                    graphicsLayer.add(measurementGraphic);

                    addMeasurementGraphic(graphic, measurementGraphic);
                }
            }

            private function addMeasurementGraphic(graphic:Graphic, measurementGraphic:Graphic):void
            {
                graphicToMeasurementGraphic[graphic] = measurementGraphic;
            }

            private function updateMeasureLabelPosition(graphic:Graphic):void
            {
                var geom:Geometry = graphic.geometry;

                switch (geom.type)
                {
//My Add
                    case Geometry.MAPPOINT:
                    {
                        measurePt = geom as MapPoint;
                        break;
                    } 
//End My Add
                    case Geometry.POLYLINE:
                    {
                        var polyline:Polyline = geom as Polyline;
                        if (polyline.paths)
                        {
                            var polylineExtent:Extent;
                            if (polyline.paths.length == 1)
                            {
                                polylineExtent = polyline.extent;
                            }
                            else
                            {
                                // Multiple paths, hence show the measurement label at the center of first path
                                var tempPolyline:Polyline = new Polyline;
                                tempPolyline.paths = [ polyline.paths[0]];
                                polylineExtent = tempPolyline.extent;
                            }
                            measurePt = polylineExtent.center;
                        }
                        break;
                    }
                    case Geometry.POLYGON:
                    {
                        var polygon:Polygon = geom as Polygon;
                        if (polygon.rings)
                        {
                            var polygonExtent:Extent;
                            if (polygon.rings.length == 1)
                            {
                                polygonExtent = polygon.extent;
                            }
                            else if (polygon.rings.length > 1)
                            {
                                // Multiple rings, hence show the measurement label at the center of first ring
                                var tempPolygon:Polygon = new Polygon;
                                tempPolygon.rings = [ polygon.rings[0]];
                                polygonExtent = tempPolygon.extent;
                            }
                            measurePt = polygonExtent.center;
                        }
                        break;
                    }
                    case Geometry.EXTENT:
                    {
                        measurePt = geom.extent.center;
                        break;
                    }
                }

                var measurementGraphic:Graphic = getMeasurementGraphic(graphic);
                if (measurementGraphic)
                {
                    measurementGraphic.geometry = measurePt;
                    measurementGraphic.visible = true;
                }
            }

            private function geometryService_simplifyCompleteHandler(event:GeometryServiceEvent):void
            {
                var polygon:Polygon = event.result[0] as Polygon;
                lastDrawnGraphic.geometry = polygon; //update to avoid simplifying again

                measureGeometry(polygon);
            }

            private function geometryService_faultHandler(info:Object, token:Object = null):void
            {
                showError(info.toString());
            }

            private function wTemplate_closeHandler(event:Event):void
            {
                graphicsLayer.visible = false;
                frmDraw.visible = false;
                showMeasurements = false;

                setMapAction(null, null, null, null); // deactivate drawTool
//My Add
                finishDrawing = true;
//End My Add
                if (selectedDrawingIcon)
                {
                    selectedDrawingIcon.filters = [];
                    selectedDrawingIcon = null;
                }
            }

            private function wTemplate_openHandler(event:Event):void
            {
                if (graphicsLayer)
                {
                    graphicsLayer.visible = true;
                }
            }

            private function editTool_UpdateHandler(event:EditEvent):void
            {
                if (!(event.graphic || event.graphics))
                {
                    return;
                }

                var graphicToMeasure:Graphic = event.graphic ? event.graphic : event.graphics[0];

                if (getMeasurementGraphic(graphicToMeasure))
                {
                    measureGraphicClientSide(graphicToMeasure);
                }
            }

            private function measureGraphicClientSide(graphic:Graphic):void
            {
                const geom:Geometry = graphic.geometry;
//My Add
                if(graphic.attributes && graphic.attributes.wkid){
                    if(graphic.attributes.wkid == map.spatialReference.wkid && geom is MapPoint){
                        calculateAreasAndLengths(geom);
                    }else{
                        updateMeasureLabelPosition(graphic);
                        return;
                    }
                }
//End My Add
                if (geom.spatialReference.wkid == EPSG_GEOGRAPHIC
                    || geom.spatialReference.isWebMercator() )
                {
                    calculateAreasAndLengths(geom);
                }
            }

            private function hideMeasurementLabel(graphic:Graphic):void
            {
                graphicToMeasurementGraphic[graphic].visible = false;
            }

            protected function editTool_editStartHandler(event:EditEvent):void
            {
                if (!(event.graphic || event.graphics))
                {
                    return;
                }

                const drawnGraphic:Graphic = event.graphic ? event.graphic : event.graphics[0];
                moveMeasurementGraphicToTop(drawnGraphic);
            }

            protected function getLongestString(... rest):String
            {
                var longest:String = "";
                for (var i:int = 0; i < rest.length; i++)
                {
                    var n:String = getDefaultString(rest[i]);
                    longest = n.length > longest.length ? n : longest;
                }
                return longest;
            }

            private function drawIcon_rollOverHandler(event:MouseEvent):void
            {
                clearSelectionFilter();
                event.target.filters = [ glowFilter ];
            }

            private function drawIcon_rollOutHandler(event:MouseEvent):void
            {
                clearSelectionFilter();
            }
            
//My Add
            private function alertClickHandler(event:CloseEvent):void
            {
                if (event.detail==Alert.YES){
                    useDefaultFont = true;
                    addGras();
                }else{
                    useDefaultFont = false;
                    addGras();
                }
            }
            
            private function saveGraLay():void
            {
                var hasText:Boolean = false;
                useDefaultFont = false;
                for (var i:int = 0; i < graphicsLayer.numGraphics; i++)
                {
                    var gra:Graphic = graphicsLayer.getChildAt(i) as Graphic;
                    switch(gra.geometry.type)
                    {
                        case Geometry.MAPPOINT:
                        {
                            if (gra.symbol is TextSymbol){
                                hasText = true;
                                break;
                            }
                        }
                    }
                }
                
                if(hasText){
                    Alert.show(fontWarnMsg, fontWarnTitle, Alert.YES|Alert.NO, null, alertClickHandler, expClass, Alert.NO);
                } else {
                    addGras();
                }
            }
            
            //File types which we want the user to open
            private static const FILE_TYPES:Array = [new FileFilter("Text File", "*.txt;*.text")];
            
            //second File types which we want the user to open
            private static const FILE_TYPES2:Array = [new FileFilter("CSV File", "*.csv;*.csv")];
            
            
            /************ Browse Event Handlers **************/
            
            //called when the user selects a file from the browse dialog
            private function onFileSelect(e:Event):void
            {
                //listen for when the file has loaded
                fr.addEventListener(Event.COMPLETE, onLoadComplete);
                
                //listen for any errors reading the file
                fr.addEventListener(IOErrorEvent.IO_ERROR, onLoadError);
                
                //load the content of the file
                fr.load();
            }
            
            //called when the user cancels out of the browser dialog
            private function onCancel(e:Event):void
            {
                trace("File Browse Canceled");
                fr = null;
            }
            
            /************ Select Event Handlers **************/
            
            //called when the file has completed loading
            private function onLoadComplete(e:Event):void
            {
                //get the data from the file as a ByteArray
                var data:ByteArray = fr.data;
                const dobj:Object = JSONUtil.decode(data.readUTFBytes(data.bytesAvailable));			
                //clean up the FileReference instance
                fr = null;
                var gras2Lbl:ArrayCollection = new ArrayCollection;
                var i:Number;
                for (i = 0; i < dobj.length; i++)
                {
                    var gObj:Object = dobj[i];
                    var gArrObj:Object;
                    var Geom:Geometry;
                    var gArray:Array;
                    var pA:Array;
                    var m:int;
                    var nX:Number;
                    var nY:Number;
                    var gA:Array;
                    var sMP:String;
                    var cMenu:ContextMenu = new ContextMenu();
                    cMenu.hideBuiltInItems();
                    if (gObj.cmenu)
                    {
                        for(var cmi:int = 0; cmi < gObj.cmenu.customItems.length; cmi ++)
                        {
                            if (gObj.cmenu.customItems[cmi].caption != clearFeatureLabel){
                                var menuItem2:ContextMenuItem = new ContextMenuItem(gObj.cmenu.customItems[cmi].caption);
                                cMenu.customItems.push(menuItem2);
                            } else {
                                var menuItem:ContextMenuItem = new ContextMenuItem(clearFeatureLabel);
                                menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, menuItem_contextMenuDeleteHandler);
                                cMenu.customItems.push(menuItem);
                            }
                        }
                    }
                    
                    switch (gObj.geomtype){
                        case "MAPPOINT":
                            gArrObj = gObj.geomarray;
                            nX = gArrObj[0].x;
                            nY = gArrObj[0].y;
                            Geom = new MapPoint(nX,nY,new SpatialReference(gObj.geomsr));
                            break;
                        case "POLYLINE":
                            gArrObj = gObj.geomarray;
                            pA = [];
                            for (m=0; m<gArrObj.length; m++)
                            {
                                nX = gArrObj[m].x;
                                nY = gArrObj[m].y;
                                pA.push(new MapPoint(nX,nY,new SpatialReference(gObj.geomsr)));
                            }
                            var pLine:Polyline = new Polyline(null,new SpatialReference(gObj.geomsr));
                            pLine.addPath(pA);
                            
                            Geom = pLine;
                            break;
                        case "POLYGON":
                            gArrObj = gObj.geomarray;
                            pA = [];
                            for (m=0; m<gArrObj.length; m++)
                            {
                                nX = gArrObj[m].x;
                                nY = gArrObj[m].y;
                                pA.push(new MapPoint(nX,nY,new SpatialReference(gObj.geomsr)));
                            }
                            var pPoly:Polygon = new Polygon(null,new SpatialReference(gObj.geomsr));
                            pPoly.addRing(pA);
                            
                            Geom = pPoly;
                            break;
                        case "EXTENT":
                            gArrObj = gObj.geomarray;
                            pA = [];
                            for (m=0; m<gArrObj.length; m++)
                            {
                                nX = gArrObj[m].x;
                                nY = gArrObj[m].y;
                                pA.push(new MapPoint(nX,nY,new SpatialReference(gObj.geomsr)));
                            }
                            var pExtent:Extent = new Extent(pA[0].x,pA[0].y, pA[1].x, pA[1].y, new SpatialReference(gObj.geomsr));
                            
                            Geom = pExtent;
                            break; 
                    }
                    var gra:Graphic = new Graphic(Geom);
                    gra.name = gObj.gname;
                    gra.id = gObj.gid;
                    gra.attributes = gObj.attrib;
                    if(gra.attributes && gra.attributes.labeled == true){
                        gras2Lbl.addItem(gra);
                    }
                    gra.contextMenu = cMenu;
                    gra.addEventListener(MouseEvent.MOUSE_DOWN, graphic_mouseDownHandler, false, 0, true);
                    lastDrawnGraphic = gra;
                    
                    switch(gObj.symtypename){
                        
                        case "TextSymbol":
                        {
                            var symFontE:String = gObj.symfonte;
                            var symFontP:String = gObj.symfontp;
                            var fBold:Boolean = symFontE.indexOf("B") > -1 ? true:false;
                            var fItal:Boolean = symFontE.indexOf("I") > -1 ? true:false;
                            var fUnd:Boolean = symFontE.indexOf("U") > -1 ? true:false;
                            var symOut:Boolean = (gObj.symcolor2 > -1)?true:false;
                            var symOutClr:uint = (gObj.symcolor2)?gObj.symcolor2:0;
                            var symBG:Boolean = (gObj.symcolor3 > -1)?true:false;
                            var symBGClr:uint = (gObj.symcolor3)?gObj.symcolor3:0;
                            var symAngle:Number = (gObj.symangle)?gObj.symangle:0;
                            var txtSym:TextSymbol = new TextSymbol(gObj.symtext,null,0,1,symOut,symOutClr,symBG,symBGClr,symFontP);
                            var txtFormat:TextFormat = new TextFormat(gObj.symtype, gObj.symsize, gObj.symcolor, fBold, fItal, fUnd);
                            txtSym.textFormat = txtFormat;
                            txtSym.angle = symAngle;
                            txtSym.yoffset = 8;
                            gra.symbol = txtSym;
                            if(gObj.symhalo){
                                gra.filters = [ measurementBorderFilter ];
                            }
                            break;
                        }
                        case "SimpleMarkerSymbol":
                        {
                            var symAngle2:Number = (gObj.symangle)?gObj.symangle:0;
                            var outlineSym0:SimpleLineSymbol = new SimpleLineSymbol(gObj.symltype, gObj.symcolor2, gObj.symalpha2, gObj.symwidth);
                            var ptSym:SimpleMarkerSymbol = new SimpleMarkerSymbol(gObj.symtype, gObj.symsize, gObj.symcolor, gObj.symalpha1,0,0,symAngle2,outlineSym0);
                            gra.symbol = ptSym;
                            break;
                        }
                        case "SimpleLineSymbol":
                        {
                            var lineSym:SimpleLineSymbol = new SimpleLineSymbol(gObj.symtype, gObj.symcolor, gObj.symalpha1, gObj.symwidth);
                            gra.symbol = lineSym;
                            break;
                        }
                        case "SimpleFillSymbol":
                        {
                            var outlineSym:SimpleLineSymbol = new SimpleLineSymbol(gObj.symltype, gObj.symcolor2, gObj.symalpha2, gObj.symwidth);
                            var polySym:SimpleFillSymbol = new SimpleFillSymbol(gObj.symtype, gObj.symcolor, gObj.symalpha1, outlineSym);
                            gra.symbol = polySym;
                            break;
                        }
                    }
                    graphicsLayer.add(gra);
                }
                updateHasDrawnGraphics();
                //Now link all the labels to thier graphics
                for each(var graphic:Graphic in gras2Lbl){
                    for (i = 0; i < graphicsLayer.numGraphics; i++){
                        var lgra:Graphic = graphicsLayer.getChildAt(i) as Graphic;
                        if(lgra.name == graphic.id){
                            addMeasurementGraphic(graphic,lgra);
                            break;
                        }
                    }
                }
            }
            
            private function onLoadComplete2(event:Event):void
            {
                //get the data from the file as a ByteArray
                const loader:URLLoader = event.target as URLLoader;
                loader.close();
                var data:ByteArray = loader.data;
                var JSONStr:String = data.readUTFBytes(data.bytesAvailable);
                const dobj:Object = JSONUtil.decode(JSONStr);			
                //clean up the FileReference instance
                fr = null;
                var gras2Lbl:ArrayCollection = new ArrayCollection;
                
                var i:Number;
                var gl:int;
                for (i = 0; i < dobj.length; i++)
                {
                    var gObj:Object = dobj[i];
                    var gArrObj:Object;
                    var Geom:Geometry;
                    var gArray:Array;
                    var pA:Array;
                    var m:int;
                    var nX:Number;
                    var nY:Number;
                    var gA:Array;
                    var sMP:String;
                    var cMenu:ContextMenu = new ContextMenu();
                    cMenu.hideBuiltInItems();
                    if (gObj.cmenu)
                    {
                        for(var cmi:int = 0; cmi < gObj.cmenu.customItems.length; cmi ++)
                        {
                            if (gObj.cmenu.customItems[cmi].caption != clearFeatureLabel){
                                var menuItem2:ContextMenuItem = new ContextMenuItem(gObj.cmenu.customItems[cmi].caption);
                                cMenu.customItems.push(menuItem2);
                            } else {
                                var menuItem:ContextMenuItem = new ContextMenuItem(clearFeatureLabel);
                                menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, menuItem_contextMenuDeleteHandler);
                                cMenu.customItems.push(menuItem);
                            }
                        }
                    }
                    
                    switch (gObj.geomtype){
                        case "MAPPOINT":
                            gArrObj = gObj.geomarray;
                            nX = gArrObj[0].x;
                            nY = gArrObj[0].y;
                            Geom = new MapPoint(nX,nY,new SpatialReference(gObj.geomsr));
                            break;
                        case "POLYLINE":
                            gArrObj = gObj.geomarray;
                            pA = [];
                            for (m=0; m<gArrObj.length; m++)
                            {
                                nX = gArrObj[m].x;
                                nY = gArrObj[m].y;
                                pA.push(new MapPoint(nX,nY,new SpatialReference(gObj.geomsr)));
                            }
                            var pLine:Polyline = new Polyline(null,new SpatialReference(gObj.geomsr));
                            pLine.addPath(pA);
                            
                            Geom = pLine;
                            break;
                        case "POLYGON":
                            gArrObj = gObj.geomarray;
                            pA = [];
                            for (m=0; m<gArrObj.length; m++)
                            {
                                nX = gArrObj[m].x;
                                nY = gArrObj[m].y;
                                pA.push(new MapPoint(nX,nY,new SpatialReference(gObj.geomsr)));
                            }
                            var pPoly:Polygon = new Polygon(null,new SpatialReference(gObj.geomsr));
                            pPoly.addRing(pA);
                            
                            Geom = pPoly;
                            break;
                        case "EXTENT":
                            gArrObj = gObj.geomarray;
                            pA = [];
                            for (m=0; m<gArrObj.length; m++)
                            {
                                nX = gArrObj[m].x;
                                nY = gArrObj[m].y;
                                pA.push(new MapPoint(nX,nY,new SpatialReference(gObj.geomsr)));
                            }
                            var pExtent:Extent = new Extent(pA[0].x,pA[0].y, pA[1].x, pA[1].y, new SpatialReference(gObj.geomsr));
                            
                            Geom = pExtent;
                            break; 
                    }
                    var gra:Graphic = new Graphic(Geom);
                    gra.name = gObj.gname;
                    gra.id = gObj.gid;
                    gra.attributes = gObj.attrib;
                    if(gra.attributes && gra.attributes.labeled == true){
                        gras2Lbl.addItem(gra);
                    }
                    gra.contextMenu = cMenu;
                    gra.addEventListener(MouseEvent.MOUSE_DOWN, graphic_mouseDownHandler, false, 0, true);
                    lastDrawnGraphic = gra;
                    
                    switch(gObj.symtypename){
                        
                        case "TextSymbol":
                        {
                            var symFontE:String = gObj.symfonte;
                            var symFontP:String = gObj.symfontp;
                            var fBold:Boolean = symFontE.indexOf("B") > -1 ? true:false;
                            var fItal:Boolean = symFontE.indexOf("I") > -1 ? true:false;
                            var fUnd:Boolean = symFontE.indexOf("U") > -1 ? true:false;
                            var symOut:Boolean = (gObj.symcolor2 > -1)?true:false;
                            var symOutClr:uint = (gObj.symcolor2)?gObj.symcolor2:0;
                            var symBG:Boolean = (gObj.symcolor3 > -1)?true:false;
                            var symBGClr:uint = (gObj.symcolor3)?gObj.symcolor3:0;
                            var symAngle:Number = (gObj.symangle)?gObj.symangle:0;
                            var txtSym:TextSymbol = new TextSymbol(gObj.symtext,null,0,1,symOut,symOutClr,symBG,symBGClr,symFontP);
                            var txtFormat:TextFormat = new TextFormat(gObj.symtype, gObj.symsize, gObj.symcolor, fBold, fItal, fUnd);
                            txtSym.textFormat = txtFormat;
                            txtSym.angle = symAngle;
                            txtSym.yoffset = 8;
                            gra.symbol = txtSym;
                            if(gObj.symhalo){
                                gra.filters = [ measurementBorderFilter ];
                            }
                            break;
                        }
                        case "SimpleMarkerSymbol":
                        {
                            var symAngle2:Number = (gObj.symangle)?gObj.symangle:0;
                            var outlineSym0:SimpleLineSymbol = new SimpleLineSymbol(gObj.symltype, gObj.symcolor2, gObj.symalpha2, gObj.symwidth);
                            var ptSym:SimpleMarkerSymbol = new SimpleMarkerSymbol(gObj.symtype, gObj.symsize, gObj.symcolor, gObj.symalpha1,0,0,symAngle2,outlineSym0);
                            gra.symbol = ptSym;
                            break;
                        }
                        case "SimpleLineSymbol":
                        {
                            var lineSym:SimpleLineSymbol = new SimpleLineSymbol(gObj.symtype, gObj.symcolor, gObj.symalpha1, gObj.symwidth);
                            gra.symbol = lineSym;
                            break;
                        }
                        case "SimpleFillSymbol":
                        {
                            var outlineSym:SimpleLineSymbol = new SimpleLineSymbol(gObj.symltype, gObj.symcolor2, gObj.symalpha2, gObj.symwidth);
                            var polySym:SimpleFillSymbol = new SimpleFillSymbol(gObj.symtype, gObj.symcolor, gObj.symalpha1, outlineSym);
                            gra.symbol = polySym;
                            break;
                        }
                    }
                    graphicsLayer.add(gra);
                }
                //Now link all the labels to thier graphics
                for each( var graphic:Graphic in gras2Lbl){
                    for (i = 0; i < graphicsLayer.numGraphics; i++){
                        var lgra:Graphic = graphicsLayer.getChildAt(i) as Graphic;
                        if(lgra.name == graphic.id){
                            addMeasurementGraphic(graphic,lgra);
                            break;
                        }
                    }
                }
                updateHasDrawnGraphics();
                if(autoZoom){
                    zoomAll();
                }
            }
            
            private function zoomAll():void
            {
                if(graphicsLayer.graphicProvider){
                    var gAC:ArrayCollection = graphicsLayer.graphicProvider as ArrayCollection;
                    if (graphicsLayer.numGraphics == 1 
                        && gAC[0].geometry.type == Geometry.MAPPOINT){
                        var mp:MapPoint = gAC[0].geometry as MapPoint;
                        map.zoom(1 / 16, mp);
                        map.centerAt(mp);
                    }else{
                        var graphicsExtent:Extent = GraphicUtil.getGraphicsExtent(gAC.source);
                        map.zoomTo(graphicsExtent.expand(zoomPercent));
                    }
                }
            }
            
            //called if an error occurs while loading the file contents
            private function onLoadError(e:IOErrorEvent):void
            {
                trace("Error loading file : " + e.text);
            }
            
            private function loadGraLay():void
            {
                //create the FileReference instance
                fr = new FileReference();
                
                //listen for when they select a file
                fr.addEventListener(Event.SELECT, onFileSelect);
                
                //listen for when then cancel out of the browse dialog
                fr.addEventListener(Event.CANCEL,onCancel);
                
                //open a native browse dialog that filters for text files
                fr.browse(FILE_TYPES);
            }
            
            private function addGras():void 
            {
                drawAC = new ArrayCollection();
                var i:Number;
                var symTypeName:String = "";
                var symType:String = "";
                var symLType:String = "";
                var symFontE:String = "";
                var symFontP:String = "middle";
                var symSize:Number = 1;
                var symColor:Number = 0x000000;
                var symColor2:Number = 0x000000;
                var symColor3:Number = 0x000000;
                var symWidth:Number = 1;
                var symText:String = "";
                var symAlpha1:Number = 1;
                var symAlpha2:Number = 1;
                var geomType:String = "";
                var geomSR:Number;
                var gname:String = "";
                var symAngle:Number = 0;
                var symHalo:Boolean = false;
                
                for (i = 0; i < graphicsLayer.numGraphics; i++)
                {
                    var geomArray:Array = [];
                    symText = "";
                    var gra:Graphic = graphicsLayer.getChildAt(i) as Graphic;
                    switch(gra.geometry.type)
                    {
                        case Geometry.MAPPOINT:
                        {
                            if (gra.symbol is TextSymbol) {
                                var txtSym:TextSymbol = gra.symbol as TextSymbol;
                                symTypeName = "TextSymbol";
                                var txtFormat:TextFormat = txtSym.textFormat;
                                if(useDefaultFont){
                                    symType = "Arial"
                                }else{
                                    symType = txtFormat.font
                                }
                                symText = txtSym.text;
                                symHalo = (gra.filters.length >0);
                                if (txtFormat.bold){
                                    symFontE += "B"
                                }
                                if (txtFormat.italic){
                                    symFontE += "I"
                                }
                                if (txtFormat.underline){
                                    symFontE += "U"
                                }
                                symSize = Number(txtFormat.size);
                                symColor = Number(txtFormat.color);
                                symAngle = txtSym.angle;
                                if(txtSym.border){
                                    symColor2 = Number(txtSym.borderColor);
                                }else{
                                    symColor2 = -1;
                                }
                                if(txtSym.background){
                                    symColor3 = Number(txtSym.backgroundColor);
                                }else{
                                    symColor3 = -1;
                                }
                                symFontP = txtSym.placement;
                            } else {
                                var ptSym:SimpleMarkerSymbol = gra.symbol as SimpleMarkerSymbol;
                                symTypeName = "SimpleMarkerSymbol";
                                symType = ptSym.style;
                                symColor = ptSym.color;
                                symSize = ptSym.size;
                                symAlpha1 = ptSym.alpha;
                                symColor2 = ptSym.outline.color;
                                symAlpha2 = ptSym.outline.alpha;
                                symWidth = ptSym.outline.width;
                                symLType = ptSym.outline.style;
                                symAngle = ptSym.angle;
                            }
                            geomType = "MAPPOINT";
                            var pnt:MapPoint = gra.geometry as MapPoint;
                            geomSR = gra.geometry.spatialReference.wkid
                            geomArray.push(pnt);
                            break;
                        }
                        case Geometry.POLYLINE:
                        {
                            var lineSym:SimpleLineSymbol = gra.symbol as SimpleLineSymbol;
                            symTypeName = "SimpleLineSymbol";
                            symType = lineSym.style;
                            symWidth = lineSym.width;
                            symAlpha1 = lineSym.alpha;
                            symColor = lineSym.color;
                            geomType = "POLYLINE";
                            var polyline:Polyline = gra.geometry as Polyline;
                            for (var i1:int = 0; i1 < polyline.paths.length; i1++)
                            {
                                for (var j:int = 0; j < polyline.paths[i1].length; j++)
                                {
                                    var mp:MapPoint = polyline.getPoint(i1,j) as MapPoint;
                                    geomArray.push(mp);
                                }
                            }
                            geomSR = gra.geometry.spatialReference.wkid
                            break;
                        }
                        case Geometry.POLYGON:
                        {
                            var polySym:SimpleFillSymbol = gra.symbol as SimpleFillSymbol;
                            symTypeName = "SimpleFillSymbol";
                            symType = polySym.style;
                            symWidth = polySym.outline.width;
                            symLType = polySym.outline.style;
                            symAlpha1 = polySym.alpha;
                            symAlpha2 = polySym.outline.alpha
                            symColor = polySym.color;
                            symColor2 = polySym.outline.color;
                            geomType = "POLYGON";
                            var poly:Polygon= gra.geometry as Polygon;
                            for (var i2:int = 0; i2 < poly.rings.length; i2++)
                            {
                                for (var j1:int = 0; j1 < poly.rings[i2].length; j1++)
                                {
                                    var mp2:MapPoint = poly.getPoint(i2,j1) as MapPoint;
                                    geomArray.push(mp2);
                                }
                            }
                            geomSR = gra.geometry.spatialReference.wkid
                            break;
                        }
                        case Geometry.EXTENT:
                        {
                            var rectSym:SimpleFillSymbol = gra.symbol as SimpleFillSymbol;
                            symTypeName = "SimpleFillSymbol";
                            symType = rectSym.style;
                            symWidth = rectSym.outline.width;
                            symLType = rectSym.outline.style;
                            symAlpha1 = rectSym.alpha;
                            symAlpha2 = rectSym.outline.alpha
                            symColor = rectSym.color;
                            symColor2 = rectSym.outline.color;
                            geomType = "EXTENT";
                            var rect:Extent= gra.geometry as Extent;
                            var mp3:MapPoint;
                            mp3 = new MapPoint(rect.xmin, rect.ymin, gra.geometry.spatialReference);
                            geomArray.push(mp3);
                            mp3 = new MapPoint(rect.xmax, rect.ymax, gra.geometry.spatialReference);
                            geomArray.push(mp3);
                            geomSR = gra.geometry.spatialReference.wkid
                            break;
                        }
                    }
                    var gObj:Object = {
                        geomtype: geomType,
                        geomarray: geomArray,
                        geomsr: geomSR,
                        symtypename: symTypeName,
                        symtype: symType,
                        symsize: symSize,
                        symangle: symAngle,
                        symcolor: symColor,
                        symcolor2: symColor2,
                        symcolor3: symColor3,
                        symwidth: symWidth,
                        symtext: symText,
                        symhalo: symHalo,
                        symalpha1: symAlpha1,
                        symalpha2: symAlpha2,
                        cmenu: gra.contextMenu,
                        symfonte: symFontE,
                        symfontp: symFontP,
                        symltype: symLType,
                        gname: gra.name,
                        gid: gra.id,
                        attrib: gra.attributes
                    }
                    drawAC.addItem(gObj);
                }
                if(!fr) fr = new FileReference();
                fr.save(JSONUtil.encode(drawAC.source),"SavedGraphics.txt")
                graphicsLayer.clear();
                updateHasDrawnGraphics();
            }
            
            protected function chkMeasurements_changeHandler(event:Event):void
            {
                if (chkMeasurements.selected){
                    wTemplate.widgetWidth = wTemplate.width = 530;
                    wTemplate.widgetHeight = wTemplate.height = 335;
                    AppEvent.dispatch(AppEvent.WIDGET_FOCUS, this.widgetId);
                }else{
                    wTemplate.widgetHeight = wTemplate.height = 265;
                    wTemplate.widgetWidth = wTemplate.width = 420;
                }
            }
            
            private function fillSymbolChangeHandler():void
            {
                if (!finishDrawing)
                {
                    setMapAction(drawType, drawStatus, fillSymbol, map_drawEndHandler, null, false, true);
                }
            }
            
            private function DisplayVersion(evt:MouseEvent):void
            {
                if(evt.altKey){
                    Alert.show("Enhanched Draw Widget Version: " + VERSION + "\nBuild Date: " + BUILDDATE,
                        wTemplate.widgetTitle, 4, null, null, iconClass);
                }
            }
//End My Add
        ]]>
    </fx:Script>

    <fx:Declarations>
<!--My Add -->				
        <mx:NumberFormatter		id="numFormatter2" 
                                useThousandsSeparator="false" 
                                precision="{numPrecision}"/>
<!-- End My Add -->
        <s:GlowFilter id="glowFilter"
                      alpha="1"
                      color="{getStyle('focusColor')}"
                      inner="true"
                      strength="2"/>

        <s:GlowFilter id="measurementBorderFilter"
                      blurX="3"
                      blurY="3"
                      color="0xFFFFFF"
                      strength="7"/>

        <esri:GeometryService id="geometryService"
                              fault="geometryService_faultHandler(event)"
                              projectComplete="geometryService_projectCompleteHandler(event)"
                              simplifyComplete="geometryService_simplifyCompleteHandler(event)"/>

        <mx:NumberFormatter id="numFormatter"
                            precision="2"
                            useThousandsSeparator="true"/>

        <esri:SimpleFillSymbol id="fillSymbol"
                               alpha="{numFillAlpha.value}"
                               color="{cpFill.selectedColor}"
                               style="{fillStyle.selectedItem.style}">
            <esri:SimpleLineSymbol width="{numFillOutlineWidth.value}" color="{cpFillOutline.selectedColor}"/>
        </esri:SimpleFillSymbol>

        <esri:SimpleLineSymbol id="lineSymbol"
                               width="{numLineWidth.value}"
                               alpha="{numLineAlpha.value}"
                               color="{cpLine.selectedColor}"
                               style="{lineStyle.selectedItem.style}"/>

        <esri:EditTool id="editTool" map="{map}"/>
    </fx:Declarations>
<!-- Add width, height, minWith, minHeight -->
    <viewer:WidgetTemplate id="wTemplate"
                           width="420" height="280"
                           closed="wTemplate_closeHandler(event)"
                           open="wTemplate_openHandler(event)"
                           minHeight="240"
                           minWidth="280">
        <s:VGroup width="100%" height="100%"
                  gap="2">
            <s:HGroup id="drawImageGroup"
                      width="100%"
                      gap="2"
                      horizontalAlign="center">
                <components:FocusableImage name="{DrawTool.MAPPOINT}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_point.png"
                                           toolTip="{drawPointLabel}"
                                           useHandCursor="true"/>

                <components:FocusableImage name="{DrawTool.POLYLINE}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_line.png"
                                           toolTip="{drawLineLabel}"
                                           useHandCursor="true"/>

                <components:FocusableImage name="{DrawTool.FREEHAND_POLYLINE}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_freeline.png"
                                           toolTip="{drawFreehandLineLabel}"
                                           useHandCursor="true"/>

                <components:FocusableImage name="{DrawTool.EXTENT}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_rect.png"
                                           toolTip="{drawRectangleLabel}"
                                           useHandCursor="true"/>

                <components:FocusableImage name="{DrawTool.CIRCLE}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_circle.png"
                                           toolTip="{drawCircleLabel}"
                                           useHandCursor="true"/>

                <components:FocusableImage name="{DrawTool.ELLIPSE}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_ellipse.png"
                                           toolTip="{drawEllipseLabel}"
                                           useHandCursor="true"/>

                <components:FocusableImage name="{DrawTool.POLYGON}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_poly.png"
                                           toolTip="{drawPolygonLabel}"
                                           useHandCursor="true"/>

                <components:FocusableImage name="{DrawTool.FREEHAND_POLYGON}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_freepoly.png"
                                           toolTip="{drawFreehandPolygonLabel}"
                                           useHandCursor="true"/>

                <components:FocusableImage id="text" name="{DrawTool.MAPPOINT}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="drawIcon_rollOutHandler(event)"
                                           rollOver="drawIcon_rollOverHandler(event)"
                                           source="assets/images/i_draw_text.png"
                                           toolTip="{addTextLabel}"
                                           useHandCursor="true"/>
            </s:HGroup>

            <s:HGroup width="100%"
                      horizontalAlign="right"
                      paddingRight="10"
                      paddingTop="2">
                <s:Label buttonMode="true"
                         click="clear()"
                         fontWeight="bold"
                         includeInLayout="{hasDrawnGraphics}"
                         text="{clearLabel}"
                         textDecoration="underline"
                         visible="{hasDrawnGraphics}"/>
            </s:HGroup>
<!--Add eDraw:FormItemVerticalAlign and labelWidth to all form items-->
            <mx:Form id="frmDraw"
                     width="100%" height="100%"
                     paddingBottom="0"
                     verticalGap="8"
                     verticalScrollPolicy="off">
                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{addingText}"
                             label="{textLabel}"
                             visible="{addingText}">
                    <s:HGroup width="100%" verticalAlign="middle">
                        <s:TextInput id="txtLabel"
                                     width="100%"
                                     text=""/>

                        <s:ToggleButton id="bold" fontSize="11"
                                        width="32"
                                        fontWeight="bold"
                                        label="{textBoldLabel}"
                                        toolTip="{textBoldTooltip}"/><!-- Added fontSize="11" -->

                        <s:ToggleButton id="italic"
                                        width="32" fontSize="11"
                                        fontStyle="italic"
                                        fontWeight="bold"
                                        label="{textItalicLabel}"
                                        toolTip="{textItalicTooltip}"/><!-- Added fontSize="11" -->

                        <s:ToggleButton id="underline"
                                        width="32" fontSize="11"
                                        fontWeight="bold"
                                        label="{textUnderlineLabel}"
                                        textDecoration="underline"
                                        toolTip="{textUnderlineTooltip}"/><!-- Added fontSize="11" -->
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{addingText}"
                             label="{textFontLabel}"
                             visible="{addingText}">
<!--My Add-->
                    <s:HGroup width="100%" gap="8" verticalAlign="middle">
                        <s:ComboBox id="fontNameSelection"
                                    dataProvider="{fontList}"
                                    requireSelection="true"/>
                        <s:CheckBox id="AddTextHaloSel" label="{AddHaloLbl}" selected="@{isHaloEnabled}" />
                    </s:HGroup>
<!--End My Add-->
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{addingText}"
                             label="{textColorLabel}"
                             visible="{addingText}">
                    <s:HGroup width="100%"
                              gap="4"
                              verticalAlign="middle">
                        <mx:ColorPicker id="cpText" selectedColor="{defaultDrawColor}"/>

                        <mx:Label text="{textSizeLabel}"/>

                        <mx:NumericStepper id="numTextSize"
                                           maximum="100"
                                           minimum="0"
                                           value="{defaultTextFontSize}"/>
<!-- My Add -->
                        <mx:Label text="{textRotateLabel}"/>
                        <mx:NumericStepper id="numTextRotation"
                                           maximum="360"
                                           minimum="-360"
                                           value="0" width="50"/>
<!-- End My Add -->
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{drawingPoint}"
                             label="{markerColorLabel}" labelWidth="80"
                             visible="{drawingPoint}">
                    <s:HGroup width="100%"
                              gap="55"
                              verticalAlign="middle">
                        <mx:ColorPicker id="cpMarker" selectedColor="{defaultDrawColor}"/>

                        <s:HGroup width="100%"
                                  gap="24"
                                  verticalAlign="middle">
                            <mx:Label text="{markerStyleLabel}"/>

                            <s:DropDownList id="markerStyle"
                                            width="100%"
                                            labelField="name"
                                            selectedIndex="0">
                                <s:typicalItem>
                                    <fx:Object name="{getLongestString('markerStyleCircle',
                                                                       'markerStyleCross',
                                                                       'markerStyleDiamond',
                                                                       'markerStyleSquare',
                                                                       'markerStyleX')}"/>
                                </s:typicalItem>
                                <s:ArrayList>
                                    <fx:Object name="{getDefaultString('markerStyleCircle')}" style="{SimpleMarkerSymbol.STYLE_CIRCLE}"/>
                                    <fx:Object name="{getDefaultString('markerStyleCross')}" style="{SimpleMarkerSymbol.STYLE_CROSS}"/>
                                    <fx:Object name="{getDefaultString('markerStyleDiamond')}" style="{SimpleMarkerSymbol.STYLE_DIAMOND}"/>
                                    <fx:Object name="{getDefaultString('markerStyleSquare')}" style="{SimpleMarkerSymbol.STYLE_SQUARE}"/>
                                    <!-- triangle style is not supported by the 10.1 print task -->
                                    <!--<fx:Object name="{getDefaultString('markerStyleTriangle')}" style="{SimpleMarkerSymbol.STYLE_TRIANGLE}"/>-->
                                    <fx:Object name="{getDefaultString('markerStyleX')}" style="{SimpleMarkerSymbol.STYLE_X}"/>
                                </s:ArrayList>
                            </s:DropDownList>
                        </s:HGroup>
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{drawingPoint}"
                             label="{markerSizeLabel}" labelWidth="80"
                             visible="{drawingPoint}">
                    <s:HGroup width="100%"
                              gap="7"
                              verticalAlign="middle">
<!-- Change gap from 21 to 7 -->
                        <mx:NumericStepper id="numMarkerSize"
                                           maximum="50"
                                           minimum="0"
                                           value="15"/>
                        <s:Label text="{markerAlphaLabel}"/>

                        <mx:NumericStepper id="numMarkerAlpha"
                                           maximum="1"
                                           minimum="0"
                                           stepSize="0.1"
                                           value="1"/>
<!-- My Add -->
                        <s:Label text="{markerRotationLabel}"/>
                        <mx:NumericStepper id="numMarkerAngle"
                                           maximum="360"
                                           minimum="-360"
                                           stepSize="1"
                                           value="0"
                                           width="50"/>
<!-- End My Add -->
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{drawingPoint}"
                             label="{markerOutlineColorLabel}" labelWidth="80"
                             visible="{drawingPoint}">
                    <s:HGroup width="100%"
                              gap="55"
                              verticalAlign="middle">
                        <mx:ColorPicker id="cpMarkerOutline" selectedColor="0x00000"/>

                        <s:HGroup width="100%"
                                  gap="24"
                                  verticalAlign="middle">
                            <s:Label text="{markerOutlineWidthLabel}"/>

                            <mx:NumericStepper id="numMarkerOutlineWidth"
                                               maximum="5"
                                               minimum="0"
                                               stepSize="1"
                                               value="1"/>
                        </s:HGroup>
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{drawingPolygon}"
                             label="{fillColorLabel}"
                             visible="{drawingPolygon}">

                    <s:HGroup width="100%"
                              gap="55"
                              verticalAlign="middle">
                        <mx:ColorPicker id="cpFill" selectedColor="{defaultDrawColor}"/>

                        <s:HGroup width="100%"
                                  gap="24"
                                  verticalAlign="middle">
                            <mx:Label text="{fillStyleLabel}"/>

                            <s:DropDownList id="fillStyle"
                                            width="100%"
                                            labelField="name"
                                            selectedIndex="0">
                                <s:typicalItem>
                                    <fx:Object name="{getLongestString('fillStyleSolid',
                                                                       'fillStyleBackwardDiagonal',
                                                                       'fillStyleCross',
                                                                       'fillStyleForwardDiagonal',
                                                                       'fillStyleHorizontal',
                                                                       'fillStyleVertical')}"/>
                                </s:typicalItem>
                                <s:ArrayList>
                                    <fx:Object name="{getDefaultString('fillStyleSolid')}" style="{SimpleFillSymbol.STYLE_SOLID}"/>
                                    <fx:Object name="{getDefaultString('fillStyleBackwardDiagonal')}" style="{SimpleFillSymbol.STYLE_BACKWARD_DIAGONAL}"/>
                                    <fx:Object name="{getDefaultString('fillStyleCross')}" style="{SimpleFillSymbol.STYLE_CROSS}"/>
                                    <fx:Object name="{getDefaultString('fillStyleForwardDiagonal')}" style="{SimpleFillSymbol.STYLE_FORWARD_DIAGONAL}"/>
                                    <fx:Object name="{getDefaultString('fillStyleHorizontal')}" style="{SimpleFillSymbol.STYLE_HORIZONTAL}"/>
                                    <fx:Object name="{getDefaultString('fillStyleVertical')}" style="{SimpleFillSymbol.STYLE_VERTICAL}"/>
                                </s:ArrayList>
                            </s:DropDownList>
                        </s:HGroup>
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{drawingPolygon}"
                             label="{fillAlphaLabel}"
                             visible="{drawingPolygon}">
                    <mx:NumericStepper id="numFillAlpha"
                                       maximum="1"
                                       minimum="0"
                                       stepSize="0.1"
                                       value="0.5"/>
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{drawingPolygon}"
                             label="{fillOutlineColorLabel}"
                             visible="{drawingPolygon}">
                    <s:HGroup width="100%"
                              gap="55"
                              verticalAlign="middle">
                        <mx:ColorPicker id="cpFillOutline" selectedColor="0x000000"/>

                        <s:HGroup width="100%"
                                  gap="24"
                                  verticalAlign="middle">
                            <s:Label text="{fillOutlineWidthLabel}"/>

                            <mx:NumericStepper id="numFillOutlineWidth"
                                               maximum="5"
                                               minimum="0"
                                               stepSize="1"
                                               value="1"/>
                        </s:HGroup>
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>
<!-- My Add -->				
                <eDraw:FormItemVerticalAlign verticalAlign="middle" id="fillOutlineAlpha"
                                             width="100%" labelWidth="80"
                                             includeInLayout="{drawingPolygon}"
                                             label="{fillOutlineAlphaLabel}"
                                             visible="{drawingPolygon}">
                    <s:HGroup width="100%"
                              gap="25"
                              verticalAlign="middle">
                        <mx:NumericStepper id="numFillOutlineAlpha"
                                           change="fillSymbolChangeHandler()"
                                           maximum="1"
                                           minimum="0"
                                           stepSize="0.1"
                                           value="0.8"/>
                        <s:HGroup width="100%"
                                  gap="22"
                                  verticalAlign="middle">
                            <mx:Label text="{fillStyleLabel}"/>
                            <s:DropDownList id="fillOutlineStyle"
                                            change="fillSymbolChangeHandler()"
                                            labelField="name"
                                            selectedIndex="0">
                                <s:ArrayList>
                                    <fx:Object name="{getDefaultString('lineStyleSolid')}" style="{SimpleLineSymbol.STYLE_SOLID}"/>
                                    <fx:Object name="{getDefaultString('lineStyleDash')}" style="{SimpleLineSymbol.STYLE_DASH}"/>
                                    <fx:Object name="{getDefaultString('lineStyleDot')}" style="{SimpleLineSymbol.STYLE_DOT}"/>
                                    <fx:Object name="{getDefaultString('lineStyleDashDot')}" style="{SimpleLineSymbol.STYLE_DASHDOT}"/>
                                    <fx:Object name="{getDefaultString('lineStyleDashDotDot')}" style="{SimpleLineSymbol.STYLE_DASHDOTDOT}"/>
                                </s:ArrayList>
                            </s:DropDownList>
                        </s:HGroup>
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>
<!-- End My Add -->
                
                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{drawingLine}"
                             label="{lineColorLabel}"
                             visible="{drawingLine}">
                    <s:HGroup width="100%"
                              gap="55"
                              verticalAlign="middle">
                        <mx:ColorPicker id="cpLine" selectedColor="{defaultDrawColor}"/>

                        <s:HGroup width="100%"
                                  gap="24"
                                  verticalAlign="middle">
                            <s:Label text="{lineStyleLabel}"/>

                            <s:DropDownList id="lineStyle"
                                            width="100%"
                                            labelField="name"
                                            selectedIndex="0">
                                <s:typicalItem>
                                    <fx:Object name="{getLongestString('lineStyleSolid',
                                                                       'lineStyleDashes',
                                                                       'lineStyleDot',
                                                                       'lineStyleDash',
                                                                       'lineStyleDot',
                                                                       'lineStyleDashDot',
                                                                       'lineStyleDashDotDot')}"/>
                                </s:typicalItem>
                                <s:ArrayList>
                                    <fx:Object name="{getDefaultString('lineStyleSolid')}" style="{SimpleLineSymbol.STYLE_SOLID}"/>
                                    <fx:Object name="{getDefaultString('lineStyleDash')}" style="{SimpleLineSymbol.STYLE_DASH}"/>
                                    <fx:Object name="{getDefaultString('lineStyleDot')}" style="{SimpleLineSymbol.STYLE_DOT}"/>
                                    <fx:Object name="{getDefaultString('lineStyleDashDot')}" style="{SimpleLineSymbol.STYLE_DASHDOT}"/>
                                    <fx:Object name="{getDefaultString('lineStyleDashDotDot')}" style="{SimpleLineSymbol.STYLE_DASHDOTDOT}"/>
                                </s:ArrayList>
                            </s:DropDownList>
                        </s:HGroup>
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>

                <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                             includeInLayout="{drawingLine}"
                             label="{lineWidthLabel}"
                             visible="{drawingLine}">
                    <s:HGroup width="100%"
                              gap="18"
                              verticalAlign="middle">
                        <mx:NumericStepper id="numLineWidth"
                                           maximum="50"
                                           minimum="0"
                                           stepSize="1"
                                           value="5"/>

                        <mx:Label text="{lineAlphaLabel}"/>

                        <mx:NumericStepper id="numLineAlpha"
                                           maximum="1"
                                           minimum="0"
                                           stepSize="0.1"
                                           value="1"/>
                    </s:HGroup>
                </eDraw:FormItemVerticalAlign>
            </mx:Form>

            <s:VGroup width="100%" height="100%"
                      gap="0"
                      includeInLayout="{showMeasurements}"
                      paddingTop="2"
                      visible="{showMeasurements}">
<!-- Add the id chkMeasurements -->
                <s:CheckBox id="chkMeasurements" label="{showmeasurementsLabel}" selected="@{isMeasuringEnabled}" click="chkMeasurements_changeHandler(event)"/>

                <mx:Form width="100%" height="100%"
                         includeInLayout="{isMeasuringEnabled}"
                         paddingBottom="0"
                         verticalScrollPolicy="off"
                         visible="{isMeasuringEnabled}">
<!-- My Add -->
                    <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                                                 includeInLayout="{chkMeasurements.selected &amp;&amp; PointXY}"
                                                 label="{pointsUnitsLabel}" labelWidth="90"
                                                 visible="{chkMeasurements.selected &amp;&amp; PointXY}" >
                        <s:DropDownList id="cboPoint" width="100%"
                                        requireSelection="true"
                                        selectedIndex="0"/>
                    </eDraw:FormItemVerticalAlign>
<!-- End My Add -->
<!-- My Change -->
                    <eDraw:FormItemVerticalAlign verticalAlign="middle" width="100%"
                                 includeInLayout="{isMeasuringEnabled &amp;&amp; !PointXY}"
                                 label="{distanceUnitsLabel}"  labelWidth="90"
                                 visible="{isMeasuringEnabled &amp;&amp; !PointXY}">
                        <s:HGroup width="100%" verticalAlign="middle">
                            <s:DropDownList id="cboDistance"
                                            labelField="name"
                                            requireSelection="true"
                                            selectedIndex="0" width="100%">
                                <s:typicalItem>
                                    <fx:Object name="{getLongestString('unitsKilometers',
                                               'unitsMiles',
                                               'unitsMeters',
                                               'unitsFeet',
                                               'unitsYards')}"/>
                                </s:typicalItem>
                                <s:ArrayList>
                                    <fx:Object name="{getDefaultString('unitsKilometers')}"
                                               abbr="{getDefaultString('unitsKilometersAbbr')}"
                                               conversion=".001"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsMiles')}"
                                               abbr="{getDefaultString('unitsMilesAbbr')}"
                                               conversion="0.000621"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsMeters')}"
                                               abbr="{getDefaultString('unitsMetersAbbr')}"
                                               conversion="1"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsFeet')}"
                                               abbr="{getDefaultString('unitsFeetAbbr')}"
                                               conversion="3.2808"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsYards')}"
                                               abbr="{getDefaultString('unitsYardsAbbr')}"
                                               conversion="1.0936133"/>
                                </s:ArrayList>
                            </s:DropDownList>
                            <s:Label text="{areaUnitsLabel}" includeInLayout="{isMeasuringEnabled &amp;&amp; drawingPolygon}"
                                      visible="{isMeasuringEnabled &amp;&amp; drawingPolygon}"/>
                            <s:DropDownList id="cboArea"
                                            labelField="name"
                                            requireSelection="true"
                                            selectedIndex="0" width="100%"
                                            includeInLayout="{isMeasuringEnabled &amp;&amp; drawingPolygon}"
                                            visible="{isMeasuringEnabled &amp;&amp; drawingPolygon}">
                                <s:typicalItem>
                                    <fx:Object name="{getLongestString('unitsSquareKilometers',
                                               'unitsSquareMiles',
                                               'unitsAcres',
                                               'unitsHectares',
                                               'unitsSquareMeters',
                                               'unitsSquareFeet',
                                               'unitsYards',
                                               'unitsSquareYards')}"/>
                                </s:typicalItem>
                                <s:ArrayList>
                                    <fx:Object name="{getDefaultString('unitsSquareKilometers')}"
                                               abbr="{getDefaultString('unitsSquareKilometersAbbr')}"
                                               conversion="0.000001"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsSquareMiles')}"
                                               abbr="{getDefaultString('unitsSquareMilesAbbr')}"
                                               conversion="0.0000003861021"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsAcres')}"
                                               abbr="{getDefaultString('unitsAcresAbbr')}"
                                               conversion="0.00024710538147"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsHectares')}"
                                               abbr="{getDefaultString('unitsHectaresAbbr')}"
                                               conversion="0.0001"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsSquareMeters')}"
                                               abbr="{getDefaultString('unitsSquareMetersAbbr')}"
                                               conversion="1"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsSquareFeet')}"
                                               abbr="{getDefaultString('unitsSquareFeetAbbr')}"
                                               conversion="10.763910417"/>
                                    
                                    <fx:Object name="{getDefaultString('unitsSquareYards')}"
                                               abbr="{getDefaultString('unitsSquareYardsAbbr')}"
                                               conversion="1.19599005"/>
                                </s:ArrayList>
                            </s:DropDownList>
                        </s:HGroup>
                    </eDraw:FormItemVerticalAlign>
<!-- End My Change -->
<!-- My Add -->
                    <eDraw:FormItemVerticalAlign verticalAlign="middle" id="txtFont2"
                                                 width="100%" labelWidth="90"
                                                 includeInLayout="{chkMeasurements.selected}"
                                                 label="{textFontLabel}"
                                                 visible="{chkMeasurements.selected}">
                        <s:HGroup width="100%"
                                  gap="4"
                                  verticalAlign="middle">
                            <s:ComboBox id="fontNameSelection2"
                                        dataProvider="{fontList}"
                                        requireSelection="true"/>
                            <s:ToggleButton id="bold2"
                                            width="28"
                                            fontWeight="bold" fontSize="11"
                                            label="{textBoldLabel}"
                                            toolTip="{textBoldTooltip}"/>
                            <s:ToggleButton id="italic2"
                                            width="28" fontSize="11"
                                            fontStyle="italic"
                                            fontWeight="bold"
                                            label="{textItalicLabel}"
                                            toolTip="{textItalicTooltip}"/>
                            <s:ToggleButton id="underline2"
                                            width="28" fontSize="11"
                                            fontWeight="bold"
                                            label="{textUnderlineLabel}"
                                            textDecoration="underline"
                                            toolTip="{textUnderlineTooltip}"/>
                            <mx:ColorPicker id="cpText2" selectedColor="0x000000"/>
                            <mx:Label text="{textSizeLabel}"/>
                            <mx:NumericStepper id="numTextSize2" width="50"
                                               maximum="100"
                                               minimum="0"
                                               value="12"/>
                        </s:HGroup>
                    </eDraw:FormItemVerticalAlign>
<!-- End My Add -->
                </mx:Form>
            </s:VGroup>
        </s:VGroup>
    </viewer:WidgetTemplate>
</viewer:BaseWidget>
